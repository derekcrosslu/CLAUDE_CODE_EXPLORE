{
  "title": "Claude Code Platform Specification Guide",
  "version": "1.0.0",
  "description": "Comprehensive execution and coding standard for Claude Code to generate, validate, and maintain error-free Python and QuantConnect-compatible code within the Letta AI framework. Optimized for Claude’s retrieval and reasoning layer.",
  "metadata": {
    "language": "Python",
    "target_environment": "QuantConnect Claude Execution Environment (Python 3.8)",
    "compatibility": ["Claude Code", "Letta AI Runtime", "QuantConnect Cloud"],
    "author": "System Specification derived from Derek Cross requirements"
  },
  "sections": [
    {
      "id": "syntax_and_naming",
      "title": "Syntax and Naming Rules",
      "rules": [
        "Use snake_case for all variable and function names.",
        "Use PascalCase for class names only.",
        "Do not mix naming conventions in a single file.",
        "Ensure docstrings are triple-quoted and concise.",
        "Follow PEP8 spacing and indentation (4 spaces, no tabs)."
      ],
      "examples": [
        {
          "good": "def calculate_delta_ratio(symbol, expiry):",
          "bad": "def CalculateDeltaRatio(Symbol, Expiry):"
        }
      ],
      "tags": ["style", "syntax", "naming", "pep8"]
    },
    {
      "id": "environment_compatibility",
      "title": "Environment Compatibility",
      "rules": [
        "Ensure code compiles and executes inside the QuantConnect Claude execution environment, not local Python.",
        "Avoid imports not preinstalled in QC. Allowed: pandas, numpy, sklearn, matplotlib, scipy, hmmlearn.",
        "Disallowed: requests, yfinance, ta, dotenv, plotly, openai, whisper, aio libraries.",
        "Never use local file operations, subprocess, or os.system calls.",
        "No async or multithreading — QC runtime is synchronous single-threaded."
      ],
      "examples": [
        {
          "good": "from AlgorithmImports import *",
          "bad": "import os; os.system('echo hello')"
        }
      ],
      "tags": ["environment", "compatibility", "dependencies"]
    },
    {
      "id": "imports_and_dependencies",
      "title": "Imports and Dependencies",
      "rules": [
        "Use fully qualified imports from AlgorithmImports.",
        "Avoid circular imports and redundant statements.",
        "Keep imports grouped and alphabetized for clarity."
      ],
      "examples": [
        {
          "good": "from AlgorithmImports import *",
          "bad": "import AlgorithmImports, sys, AlgorithmImports"
        }
      ],
      "tags": ["imports", "dependencies"]
    },
    {
      "id": "algorithm_structure",
      "title": "Algorithm Initialization and Structure",
      "rules": [
        "Always define initialize(self) with set_start_date, set_end_date, set_cash, and add_equity or add_option.",
        "Never access attributes before security creation.",
        "Do not assign objects dynamically inside on_data; define them in initialize.",
        "Avoid print(); use self.debug() or self.log()."
      ],
      "examples": [
        {
          "good": "def initialize(self): self.spy = self.add_equity('SPY', Resolution.Minute)",
          "bad": "def on_data(self, data): self.spy = self.add_equity('SPY')"
        }
      ],
      "tags": ["structure", "lifecycle", "initialize"]
    },
    {
      "id": "option_chains_and_strategies",
      "title": "Option Chains and Strategy Combos",
      "rules": [
        "Always subscribe to the underlying before adding options.",
        "Access data.option_chains only after confirming it's non-empty.",
        "Convert chain to list before filtering or sorting.",
        "Use datetime.date() for expiry comparisons.",
        "Use OptionStrategies helpers for multi-leg trades (calendar, vertical, condor, etc.).",
        "Check leg direction carefully: positive quantity = long, negative = short.",
        "Refresh contracts from live chain every trade; never reuse old references.",
        "Guard on_data against missing Greeks or implied volatility.",
        "Execute combos via add_option_strategy(), not market_order().",
        "Use on_order_event to confirm fills and maintain self.active_positions dict."
      ],
      "examples": [
        {
          "good": "strategy = OptionStrategies.calendar_spread(symbol, near_expiry, far_expiry, strike)\nself.add_option_strategy(strategy, 1)",
          "bad": "self.market_order(contract.symbol, 1)"
        }
      ],
      "tags": ["options", "strategies", "calendar_spread", "combos"]
    },
    {
      "id": "data_access_and_indicators",
      "title": "Data Access and Indicators",
      "rules": [
        "Use consolidators and QC indicators for time series data.",
        "Warm up all indicators or guard with self.is_warming_up.",
        "Avoid loops with history() — prefetch data outside loops.",
        "Store indicator state per symbol in self.symbol_data dict."
      ],
      "examples": [
        {
          "good": "if self.is_warming_up: return",
          "bad": "for bar in self.history(['SPY'], 100, Resolution.Minute): ..."
        }
      ],
      "tags": ["data", "indicators", "history"]
    },
    {
      "id": "data_structures_and_state",
      "title": "Data Structures and State Management",
      "rules": [
        "Prefer dicts and lists over defaultdict or complex objects.",
        "Store persistent state as attributes (self.).",
        "Avoid globals and external references.",
        "Do not pickle or serialize within QC runtime."
      ],
      "examples": [
        {
          "good": "self.symbol_data = {symbol: {\"roc\": None, \"greeks\": None}}",
          "bad": "global positions; positions = {}"
        }
      ],
      "tags": ["data", "state", "memory"]
    },
    {
      "id": "logging_and_debugging",
      "title": "Logging and Debugging",
      "rules": [
        "Use self.debug() for quick logging, self.log() for standard, self.error() for exceptions.",
        "Throttle debug statements in on_data to prevent spam.",
        "Avoid print() or external logging frameworks."
      ],
      "examples": [
        {
          "good": "self.debug(f'IV ratio: {iv_ratio:.2f}')",
          "bad": "print('IV ratio:', iv_ratio)"
        }
      ],
      "tags": ["logging", "debug"]
    },
    {
      "id": "execution_and_order_management",
      "title": "Execution and Order Management",
      "rules": [
        "Execute trades only after confirming sufficient portfolio value.",
        "Check self.portfolio.invested before re-entering.",
        "Close and rebuild multi-leg combos; do not modify live legs.",
        "Use on_order_event for fills and order tracking."
      ],
      "examples": [
        {
          "good": "if not self.portfolio.invested: self.add_option_strategy(strategy, 1)",
          "bad": "self.add_option_strategy(strategy, 1)"
        }
      ],
      "tags": ["execution", "orders", "risk"]
    },
    {
      "id": "finalization",
      "title": "Finalization and Runtime Notes",
      "rules": [
        "Do not assume access to file system or OS variables.",
        "Do not use f-string format specifiers beyond Python 3.8 compatibility.",
        "Avoid async/await or parallel execution.",
        "End algorithm scripts cleanly; omit __main__ guards in QC context."
      ],
      "examples": [
        {
          "good": "# runs safely inside QC cloud",
          "bad": "if __name__ == '__main__': QCAlgorithm.main()"
        }
      ],
      "tags": ["runtime", "compatibility"]
    }
  ],
  "summary": {
    "core_principles": [
      "Write deterministic, environment-safe Python.",
      "Avoid runtime dependencies unavailable in QC.",
      "Guard every data access and execution path.",
      "Leverage OptionStrategies to prevent structural errors.",
      "Prefer explicit initialization and state management."
    ],
    "quick_checklist": [
      "✅ snake_case everywhere",
      "✅ valid QC imports",
      "✅ initialize() defines dates, cash, assets",
      "✅ no file I/O or async",
      "✅ on_data guards for empty chains",
      "✅ use self.debug() not print()",
      "✅ OptionStrategies for combos",
      "✅ define self.symbol_data in initialize",
      "✅ avoid emogies on all code"
    ]
  }
}
