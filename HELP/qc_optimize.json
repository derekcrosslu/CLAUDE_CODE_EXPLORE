{
  "tool": "qc_optimize",
  "version": "2.2.0",
  "description": "QuantConnect parameter optimization for Phase 4 tuning",
  "sections": [
    {
      "id": "cli_commands",
      "title": "CLI Commands Reference",
      "content": "**Top-Level Commands**\n\nAll commands use: `venv/bin/python SCRIPTS/qc_optimize.py <command> [options]`\n\n---\n\n## help - Show Reference Documentation\n\n```bash\nqc_optimize help [--section <id>] [--search <query>] [--list-sections]\n```\n\n**Options**:\n- `--section <id>`: Show specific section by ID\n- `--search <query>`: Search help content for query\n- `--list-sections`: List all available section IDs\n\n**Examples**:\n```bash\n# Full help (all sections)\nqc_optimize help\n\n# Specific section\nqc_optimize help --section overfitting_detection\n\n# Search for topic\nqc_optimize help --search \"grid search\"\n\n# List all sections\nqc_optimize help --list-sections\n```\n\n**Output**: Complete reference documentation loaded from HELP/qc_optimize.json\n\n---\n\n## run - Execute Parameter Optimization\n\n```bash\nqc_optimize run --config <file> [options]\n```\n\n**Required**:\n- `--config PATH`: Optimization parameters JSON file (required)\n\n**Optional**:\n- `--state PATH`: iteration_state.json path (default: `iteration_state.json`)\n- `--output PATH`: Output file path (default: `PROJECT_LOGS/optimization_result.json`)\n- `--estimate-only`: Only estimate cost, don't run optimization\n- `--strategy TEXT`: Optimization strategy (default: `grid`)\n  - `grid`: Grid search (exhaustive, ONLY option on QC Cloud)\n  - `euler`: Euler search (NOT supported on QC Cloud API)\n  - Custom: Full class name (e.g., `QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy`)\n- `--max-backtests INT`: Maximum backtests for random strategies (NOT used for grid search)\n\n**Examples**:\n```bash\n# Run optimization\nqc_optimize run --config optimization_params.json\n\n# Estimate cost only (no execution)\nqc_optimize run --config params.json --estimate-only\n\n# Custom output location\nqc_optimize run --config params.json --output results/opt_20251113.json\n\n# Specify strategy explicitly\nqc_optimize run --config params.json --strategy grid\n```\n\n**Input File Format** (`optimization_params.json`):\n```json\n{\n  \"parameters\": [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5},\n    {\"name\": \"stop_loss\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}\n  ],\n  \"target\": \"TotalPerformance.PortfolioStatistics.SharpeRatio\",\n  \"targetTo\": \"max\",\n  \"nodeType\": \"O2-8\",\n  \"parallelNodes\": 2\n}\n```\n\n**Output** (`PROJECT_LOGS/optimization_result.json`):\n```json\n{\n  \"optimization_id\": \"abc123def456\",\n  \"best_backtest_id\": \"xyz789\",\n  \"best_sharpe\": 1.02,\n  \"baseline_sharpe\": 0.85,\n  \"improvement\": 0.20,\n  \"best_parameters\": {\n    \"rsi_period\": 15,\n    \"stop_loss\": 0.05\n  },\n  \"total_combinations\": 9,\n  \"timestamp\": \"2025-11-13T14:30:00Z\"\n}\n```\n\n**Return Codes**:\n- `0`: Success\n- `1`: Error (missing prerequisites, API failure, timeout, etc.)\n\n**Runtime**: 10-30 minutes typical (depends on combinations and backtest complexity)\n\n---\n\n## status - Check Optimization Status\n\n```bash\nqc_optimize status --optimization-id <id>\n```\n\n**Required**:\n- `--optimization-id TEXT`: Optimization ID from QC (required)\n\n**Examples**:\n```bash\n# Check status\nqc_optimize status --optimization-id abc123def456\n```\n\n**Output**:\n```\n\ud83d\udd0d Checking status: abc123def456\n\n\ud83d\udcca Status: running\n   Progress: 45.0%\n```\n\n**Possible Statuses**:\n- `running`: In progress\n- `completed`: Finished successfully\n- `error`: Failed\n- `cancelled`: User cancelled\n\n---\n\n## results - Download Optimization Results\n\n```bash\nqc_optimize results --optimization-id <id> [--output <file>]\n```\n\n**Required**:\n- `--optimization-id TEXT`: Optimization ID from QC (required)\n\n**Optional**:\n- `--output PATH`: Output file (default: `PROJECT_LOGS/optimization_result.json`)\n\n**Examples**:\n```bash\n# Download results (default location)\nqc_optimize results --optimization-id abc123def456\n\n# Custom output file\nqc_optimize results --optimization-id abc123 --output my_results.json\n```\n\n**Output**: Same JSON format as `run` command output\n\n**Use Case**: Retrieve results from optimization that completed in previous session\n\n---\n\n## Complete Workflow Example\n\n```bash\n# 1. Estimate cost first\nqc_optimize run --config params.json --estimate-only\n# Output: Estimated cost: $3.50\n\n# 2. Run optimization\nqc_optimize run --config params.json\n# Output: Optimization ID: abc123def456\n# (Waits for completion, 10-30 min)\n\n# 3. Check status (if needed, in different terminal)\nqc_optimize status --optimization-id abc123def456\n# Output: Status: running, Progress: 67%\n\n# 4. Results automatically saved to PROJECT_LOGS/optimization_result.json\n# Or retrieve manually:\nqc_optimize results --optimization-id abc123def456\n```",
      "tags": [
        "cli",
        "commands",
        "reference"
      ],
      "priority": 1,
      "related_sections": [
        "api_methods",
        "workflow_overview"
      ]
    },
    {
      "id": "api_methods",
      "title": "API Methods Reference (qc_api.py)",
      "content": "**Low-Level API Methods Used by qc_optimize.py**\n\nThese are the `qc_api.py` methods that `qc_optimize.py` calls under the hood.\n\n---\n\n## estimate_optimization()\n\n**Purpose**: Estimate cost and time for optimization before running\n\n**Signature**:\n```python\napi.estimate_optimization(\n    project_id: int,\n    parameters: list,\n    node_type: str = \"O2-8\",\n    parallel_nodes: int = 2\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID (from iteration_state.json)\n- `parameters`: List of parameter dicts with `name`, `min`, `max`, `step`\n- `node_type`: Compute node type (`O2-8`, `O4-12`, `O8-16`)\n- `parallel_nodes`: Number of parallel nodes (1-6)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'estimatedCost': 3.50,  # USD\n    'estimatedTime': 1800,  # seconds\n    'combinations': 9\n}\n```\n\n**Example**:\n```python\nfrom qc_api import QuantConnectAPI\nimport json\n\napi = QuantConnectAPI()\n\n# Read project_id from iteration_state.json\nwith open('iteration_state.json') as f:\n    state = json.load(f)\nproject_id = state['project']['project_id']\n\n# Define parameters\nparams = [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5},\n    {\"name\": \"stop_loss\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}\n]\n\n# Estimate cost\nestimate = api.estimate_optimization(\n    project_id=project_id,\n    parameters=params,\n    node_type=\"O2-8\",\n    parallel_nodes=2\n)\n\nif estimate['success']:\n    print(f\"Cost: ${estimate['estimatedCost']}\")\n    print(f\"Time: {estimate['estimatedTime']/60} minutes\")\n```\n\n**HTTP Endpoint**: `POST /optimize/estimate`\n\n---\n\n## create_optimization()\n\n**Purpose**: Submit optimization job to QuantConnect\n\n**Signature**:\n```python\napi.create_optimization(\n    project_id: int,\n    name: str,\n    target: str,\n    parameters: list,\n    target_to: str = \"max\",\n    strategy: str = \"QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy\",\n    node_type: str = \"O2-8\",\n    parallel_nodes: int = 2\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID (from iteration_state.json)\n- `name`: Optimization name (e.g., `\"Optimization_20251113_143000\"`)\n- `target`: Metric to optimize (e.g., `\"TotalPerformance.PortfolioStatistics.SharpeRatio\"`)\n- `parameters`: List of parameter dicts\n- `target_to`: `\"max\"` or `\"min\"`\n- `strategy`: Optimization strategy class (ONLY `GridSearchOptimizationStrategy` supported on Cloud)\n- `node_type`: Compute node type\n- `parallel_nodes`: Number of parallel nodes\n\n**Returns**:\n```python\n{\n    'success': True,\n    'optimizations': [\n        {\n            'optimizationId': 'abc123def456',\n            'projectId': 12345,\n            'status': 'running',\n            'name': 'Optimization_20251113_143000'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\nfrom datetime import datetime\n\nopt_name = f\"Optimization_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n\nresult = api.create_optimization(\n    project_id=12345,\n    name=opt_name,\n    target=\"TotalPerformance.PortfolioStatistics.SharpeRatio\",\n    parameters=params,\n    target_to=\"max\",\n    strategy=\"QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy\",\n    node_type=\"O2-8\",\n    parallel_nodes=2\n)\n\nif result['success']:\n    optimization_id = result['optimizations'][0]['optimizationId']\n    print(f\"Optimization started: {optimization_id}\")\nelse:\n    print(f\"Failed: {result.get('errors')}\")\n```\n\n**HTTP Endpoint**: `POST /optimize/create`\n\n---\n\n## wait_for_optimization()\n\n**Purpose**: Poll optimization status until completion or timeout\n\n**Signature**:\n```python\napi.wait_for_optimization(\n    optimization_id: str,\n    timeout: int = 1800,\n    poll_interval: int = 15\n) -> dict\n```\n\n**Parameters**:\n- `optimization_id`: Optimization ID from `create_optimization()`\n- `timeout`: Maximum wait time in seconds (default: 1800 = 30 min)\n- `poll_interval`: Seconds between status checks (default: 15)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'optimization': {\n        'optimizationId': 'abc123def456',\n        'status': 'completed',\n        'backtestId': 'xyz789',\n        'sharpeRatio': 1.02,\n        'parameterSet': [\n            {'name': 'rsi_period', 'value': 15},\n            {'name': 'stop_loss', 'value': 0.05}\n        ]\n    }\n}\n```\n\n**Behavior**:\n- Polls every `poll_interval` seconds\n- Returns when status == `'completed'`\n- Raises timeout error if exceeds `timeout`\n- Displays progress updates to console\n\n**Example**:\n```python\n# Wait for completion (blocks until done)\nfinal = api.wait_for_optimization(\n    optimization_id='abc123def456',\n    timeout=1800  # 30 minutes\n)\n\nif final['success']:\n    opt_data = final['optimization']\n    best_sharpe = opt_data['sharpeRatio']\n    best_params = {p['name']: p['value'] for p in opt_data['parameterSet']}\n    print(f\"Best Sharpe: {best_sharpe}\")\n    print(f\"Best Parameters: {best_params}\")\nelse:\n    print(f\"Failed: {final.get('error')}\")\n```\n\n**HTTP Endpoint**: `GET /optimize/read` (called repeatedly)\n\n---\n\n## get_optimization_status()\n\n**Purpose**: Get current optimization status (single check, non-blocking)\n\n**Signature**:\n```python\napi.get_optimization_status(\n    optimization_id: str\n) -> dict\n```\n\n**Parameters**:\n- `optimization_id`: Optimization ID\n\n**Returns**:\n```python\n{\n    'success': True,\n    'optimization': {\n        'optimizationId': 'abc123def456',\n        'status': 'running',\n        'progress': 0.45  # 0.0 to 1.0\n    }\n}\n```\n\n**Example**:\n```python\nstatus = api.get_optimization_status('abc123def456')\nif status['success']:\n    opt = status['optimization']\n    print(f\"Status: {opt['status']}\")\n    print(f\"Progress: {opt['progress']*100:.1f}%\")\n```\n\n**HTTP Endpoint**: `GET /optimize/read`\n\n---\n\n## get_optimization_results()\n\n**Purpose**: Download complete optimization results\n\n**Signature**:\n```python\napi.get_optimization_results(\n    optimization_id: str\n) -> dict\n```\n\n**Parameters**:\n- `optimization_id`: Optimization ID\n\n**Returns**:\n```python\n{\n    'success': True,\n    'optimization': {\n        'optimizationId': 'abc123def456',\n        'status': 'completed',\n        'backtestId': 'xyz789',  # Best backtest ID\n        'sharpeRatio': 1.02,\n        'parameterSet': [\n            {'name': 'rsi_period', 'value': 15},\n            {'name': 'stop_loss', 'value': 0.05}\n        ],\n        'statistics': { /* full backtest statistics */ }\n    }\n}\n```\n\n**Example**:\n```python\nresults = api.get_optimization_results('abc123def456')\nif results['success']:\n    opt = results['optimization']\n    \n    # Extract best parameters\n    best_params = {p['name']: p['value'] for p in opt['parameterSet']}\n    \n    # Save to file\n    import json\n    with open('optimization_result.json', 'w') as f:\n        json.dump(opt, f, indent=2)\n```\n\n**HTTP Endpoint**: `GET /optimize/read`\n\n---\n\n## Complete API Workflow\n\n```python\nfrom qc_api import QuantConnectAPI\nimport json\nfrom datetime import datetime\n\n# Initialize API\napi = QuantConnectAPI()\n\n# Step 1: Read project_id from iteration_state.json\nwith open('iteration_state.json') as f:\n    state = json.load(f)\nproject_id = state['project']['project_id']\nbaseline_sharpe = state['backtest_results']['performance']['sharpe_ratio']\n\n# Step 2: Define parameters\nparams = [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5},\n    {\"name\": \"stop_loss\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}\n]\n\n# Step 3: Estimate cost\nestimate = api.estimate_optimization(\n    project_id=project_id,\n    parameters=params,\n    node_type=\"O2-8\",\n    parallel_nodes=2\n)\nprint(f\"Estimated cost: ${estimate['estimatedCost']}\")\n\n# Step 4: Create optimization\nopt_name = f\"Optimization_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\nresult = api.create_optimization(\n    project_id=project_id,\n    name=opt_name,\n    target=\"TotalPerformance.PortfolioStatistics.SharpeRatio\",\n    parameters=params,\n    target_to=\"max\",\n    strategy=\"QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy\",\n    node_type=\"O2-8\",\n    parallel_nodes=2\n)\n\noptimization_id = result['optimizations'][0]['optimizationId']\nprint(f\"Optimization ID: {optimization_id}\")\n\n# Step 5: Wait for completion\nfinal = api.wait_for_optimization(optimization_id, timeout=1800)\n\n# Step 6: Extract results\nopt_data = final['optimization']\nbest_sharpe = opt_data['sharpeRatio']\nbest_params = {p['name']: p['value'] for p in opt_data['parameterSet']}\n\n# Step 7: Calculate improvement\nimprovement = (best_sharpe - baseline_sharpe) / baseline_sharpe\n\nprint(f\"Baseline Sharpe: {baseline_sharpe:.3f}\")\nprint(f\"Optimized Sharpe: {best_sharpe:.3f}\")\nprint(f\"Improvement: {improvement*100:+.1f}%\")\nprint(f\"Best Parameters: {best_params}\")\n```",
      "tags": [
        "api",
        "methods",
        "qc_api"
      ],
      "priority": 1,
      "related_sections": [
        "cli_commands",
        "executing_optimization"
      ]
    },
    {
      "id": "workflow_overview",
      "title": "Phase 4 Workflow Overview",
      "content": "**Prerequisites**:\n- `/qc-init` completed (iteration_state.json exists)\n- `/qc-backtest` completed (project_id and baseline results exist)\n\n**Optimization Workflow**:\n\n1. **Read iteration_state.json** - Get project_id from backtest phase\n2. **Define parameter grid** - Create optimization_params.json\n3. **Estimate cost** - Use --estimate-only flag\n4. **Run optimization** - QC tests all parameter combinations\n5. **Evaluate results** - Automatic decision based on improvement\n6. **Route decision** - USE_BASELINE, PROCEED_TO_VALIDATION, or ESCALATE\n\n**CRITICAL RULE**: MUST use project_id from iteration_state.json (created by /qc-backtest). NEVER create new project in this phase.\n\n**Why Project ID Matters**:\n- QC API requires baseline backtest in project\n- Cannot optimize empty project\n- Must optimize correct strategy\n- Maintains continuity across phases\n\n**Workflow Location**: Phase 4 (between backtest and validation)",
      "tags": [
        "workflow",
        "overview",
        "phase4"
      ],
      "priority": 1,
      "related_sections": [
        "qc_platform_access",
        "executing_optimization"
      ]
    },
    {
      "id": "qc_platform_access",
      "title": "QuantConnect Platform Access",
      "content": "**Authentication Setup**\n\n1. Get API credentials from QuantConnect:\n   - Visit: https://www.quantconnect.com/account\n   - Copy User ID and API Token\n\n2. Create `.env` file in project root:\n```bash\nQUANTCONNECT_USER_ID=your_user_id_here\nQUANTCONNECT_API_TOKEN=your_api_token_here\n```\n\n3. Verify authentication:\n```python\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\nprojects = api.list_projects()\nprint(f\"Found {len(projects.get('projects', []))} projects\")\n```\n\n**Using Existing Project from iteration_state.json**\n\n\u26a0\ufe0f **CRITICAL: NEVER create new project in optimization phase!**\n\n```python\nimport json\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\n\n# \u2705 CORRECT: Read project_id from iteration_state.json\nwith open('iteration_state.json') as f:\n    state = json.load(f)\n\nproject_id = state['project']['project_id']\n\n# Validate project exists (created by /qc-backtest)\nif not project_id:\n    raise ValueError(\"No project_id found. Run /qc-backtest first.\")\n\nprint(f\"Using existing project: {project_id}\")\n\n# Verify baseline backtest exists\nbacktest_id = state.get('backtest_results', {}).get('backtest_id')\nif not backtest_id:\n    raise ValueError(\"No baseline backtest. Run /qc-backtest first.\")\n```\n\n**File Operations on Existing Project**\n\n```python\n# Upload updated strategy file\nwith open('strategy.py') as f:\n    code = f.read()\n\nresult = api.upload_file(project_id, \"main.py\", code)\nif result['success']:\n    print(\"Strategy uploaded successfully\")\n\n# Read files from project\nfiles = api.read_files(project_id)\nfor file in files['files']:\n    print(f\"  {file['name']}\")\n```\n\n**Common Errors**:\n- \"Authentication failed\": Check .env credentials\n- \"No project_id in iteration_state.json\": Run /qc-backtest first\n- \"No baseline backtest\": Complete Phase 3 before optimization\n- \"Project not found\": Verify project_id is correct",
      "tags": [
        "authentication",
        "platform",
        "setup"
      ],
      "priority": 1,
      "related_sections": [
        "workflow_overview",
        "executing_optimization"
      ]
    },
    {
      "id": "executing_optimization",
      "title": "Executing Optimization on QC Platform",
      "content": "**Step 1: Load Project from iteration_state.json**\n\n```python\nimport json\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\n\n# Load iteration state (has project_id from /qc-backtest)\nwith open('iteration_state.json') as f:\n    state = json.load(f)\n\nproject_id = state['project']['project_id']\nbaseline_sharpe = state['backtest_results']['performance']['sharpe_ratio']\n\nif not project_id:\n    raise ValueError(\"Run /qc-backtest first to create project\")\n\nprint(f\"Project ID: {project_id}\")\nprint(f\"Baseline Sharpe: {baseline_sharpe:.3f}\")\n```\n\n**Step 2: Upload Strategy (if modified)**\n\n```python\n# Upload strategy to existing project\nwith open('strategy.py') as f:\n    code = f.read()\n\napi.upload_file(project_id, \"main.py\", code)\nprint(\"Strategy uploaded\")\n```\n\n**Step 3: Define Parameter Grid**\n\n```python\n# Keep combinations small (< 50 recommended)\nparams = [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5},  # 3 values\n    {\"name\": \"stop_loss\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}  # 3 values\n]\n# Total: 3 \u00d7 3 = 9 combinations\n```\n\n**Step 4: Estimate Cost (optional but recommended)**\n\n```python\nestimate = api.estimate_optimization(\n    project_id=project_id,\n    parameters=params,\n    node_type=\"O2-8\",\n    parallel_nodes=2\n)\n\nprint(f\"Estimated cost: ${estimate.get('estimatedCost', 'Unknown')}\")\nprint(f\"Combinations: {len(params[0])} \u00d7 {len(params[1])} = {len(params[0]) * len(params[1])}\")\n```\n\n**Step 5: Submit Optimization**\n\n```python\nfrom datetime import datetime\n\nopt_name = f\"Optimization_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n\nresult = api.create_optimization(\n    project_id=project_id,\n    name=opt_name,\n    target=\"TotalPerformance.PortfolioStatistics.SharpeRatio\",\n    parameters=params,\n    target_to=\"max\",\n    strategy=\"QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy\",\n    node_type=\"O2-8\",\n    parallel_nodes=2\n)\n\nif result.get('success'):\n    optimization_id = result['optimizations'][0]['optimizationId']\n    print(f\"Optimization started: {optimization_id}\")\nelse:\n    print(f\"Failed: {result.get('errors')}\")\n```\n\n**Step 6: Wait for Completion**\n\n```python\n# Auto-polls every 15 seconds\nfinal = api.wait_for_optimization(optimization_id, timeout=1800)\n\nif final.get('success'):\n    opt_data = final['optimization']\n    best_sharpe = opt_data['sharpeRatio']\n    best_params = {p['name']: p['value'] for p in opt_data['parameterSet']}\n    \n    print(f\"Best Sharpe: {best_sharpe:.3f}\")\n    print(f\"Best Parameters: {best_params}\")\nelse:\n    print(f\"Optimization failed: {final.get('error')}\")\n```\n\n**Step 7: Calculate Improvement & Make Decision**\n\n```python\nimprovement = (best_sharpe - baseline_sharpe) / baseline_sharpe\n\nprint(f\"Baseline: {baseline_sharpe:.3f}\")\nprint(f\"Optimized: {best_sharpe:.3f}\")\nprint(f\"Improvement: {improvement*100:+.1f}%\")\n\n# Automatic decision thresholds\nif improvement < 0.05:\n    decision = \"USE_BASELINE\"\n    reason = \"Improvement too small (< 5%)\"\nelif improvement > 0.30:\n    decision = \"ESCALATE_TO_HUMAN\"\n    reason = \"Improvement too large (> 30%) - likely overfitting\"\nelse:\n    decision = \"PROCEED_TO_VALIDATION\"\n    reason = \"Good improvement (5-30%)\"\n\nprint(f\"Decision: {decision}\")\nprint(f\"Reason: {reason}\")\n```\n\n**Via CLI** (recommended - handles all above automatically):\n\n```bash\n# Run optimization\nvenv/bin/python SCRIPTS/qc_optimize.py run --config optimization_params.json\n\n# Check status\nvenv/bin/python SCRIPTS/qc_optimize.py status --optimization-id <id>\n\n# Get results\nvenv/bin/python SCRIPTS/qc_optimize.py results --optimization-id <id>\n```",
      "tags": [
        "execution",
        "optimization",
        "workflow"
      ],
      "priority": 1,
      "related_sections": [
        "qc_platform_access",
        "parameter_grids"
      ]
    },
    {
      "id": "research_notebook_usage",
      "title": "Using QC Research Notebook for Optimization Analysis",
      "content": "**QC Research Environment**\n\nResearch notebooks (.ipynb) run in QC's cloud environment with full market data access.\n\n**Use Case for Optimization**:\n- Analyze parameter sensitivity\n- Visualize optimization results\n- Perform Monte Carlo validation\n- Generate heat maps of parameter performance\n\n**Uploading Research Notebook to Existing Project**\n\n\u26a0\ufe0f **Use existing project from iteration_state.json, NOT new project**\n\n```python\nimport json\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\n\n# \u2705 CORRECT: Use existing project from iteration_state.json\nwith open('iteration_state.json') as f:\n    state = json.load(f)\n\nproject_id = state['project']['project_id']\n\nif not project_id:\n    raise ValueError(\"Run /qc-backtest first to create project\")\n\n# Upload research notebook to existing project\nwith open('optimization_analysis.ipynb') as f:\n    notebook_content = f.read()\n\nresult = api.upload_file(project_id, \"research.ipynb\", notebook_content)\nif result['success']:\n    print(f\"Notebook uploaded to project {project_id}\")\n```\n\n**Example Research Notebook Structure**\n\n```python\n# Cell 1: Import QuantBook\nfrom QuantConnect import *\nfrom QuantConnect.Data import *\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nqb = QuantBook()\n\n# Cell 2: Load optimization results\nwith open('optimization_results.json') as f:\n    opt_results = json.load(f)\n\n# Cell 3: Create parameter heatmap\nrsi_values = [10, 15, 20]\nstop_values = [0.03, 0.05, 0.07]\nsharpe_grid = np.array([[...]])  # From results\n\nplt.imshow(sharpe_grid, cmap='viridis')\nplt.colorbar(label='Sharpe Ratio')\nplt.xticks(range(len(rsi_values)), rsi_values)\nplt.yticks(range(len(stop_values)), stop_values)\nplt.xlabel('RSI Period')\nplt.ylabel('Stop Loss %')\nplt.title('Parameter Optimization Heatmap')\nplt.show()\n\n# Cell 4: Analyze parameter sensitivity\n# Which parameter has more impact?\nrsi_sensitivity = sharpe_grid.std(axis=0).mean()\nstop_sensitivity = sharpe_grid.std(axis=1).mean()\n\nprint(f\"RSI sensitivity: {rsi_sensitivity:.3f}\")\nprint(f\"Stop sensitivity: {stop_sensitivity:.3f}\")\n```\n\n**Accessing Research Notebook**:\n\n1. Visit: https://www.quantconnect.com/terminal\n2. Navigate to project (use project_id from iteration_state.json)\n3. Open research.ipynb\n4. Run cells interactively\n\n**Best Practices**:\n- Use notebooks for analysis AFTER optimization completes\n- Don't use notebooks to RUN optimization (use API)\n- Save plots and findings to project files\n- Export analysis before deleting projects",
      "tags": [
        "research",
        "notebook",
        "analysis"
      ],
      "priority": 2,
      "related_sections": [
        "qc_platform_access",
        "executing_optimization"
      ]
    },
    {
      "id": "optimization_strategies",
      "title": "Optimization Strategy (Grid Search Only)",
      "content": "**Grid Search - ONLY Option on QuantConnect**\n\nQuantConnect Cloud API only supports grid search optimization.\n\n**Strategy Class**:\n`QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy`\n\n**Behavior**:\n- Tests ALL parameter combinations exhaustively\n- Guaranteed to find best combination in grid\n- Cost scales linearly with combinations\n\n**Pros**:\n- Complete coverage of parameter space\n- No randomness - deterministic results\n- Easy to understand and explain\n\n**Cons**:\n- Slow and expensive with large grids\n- Exponential growth with parameters\n- Can overfit if grid too fine\n\n**IMPORTANT**: Keep grids small!\n- Recommended: < 50 combinations\n- Maximum practical: ~100 combinations\n- Cost increases linearly: 100 combos = 100 backtests\n\n**Managing Large Parameter Spaces**:\n\n1. **One Parameter at a Time**:\n```json\n{\n  \"stage\": \"Optimize RSI first\",\n  \"parameters\": [{\"name\": \"rsi_period\", \"min\": 10, \"max\": 30, \"step\": 5}]\n}\n```\n\n2. **Coarse Then Fine (Multi-Stage)**:\n```json\n{\n  \"stage_1\": \"Wide range, large steps\",\n  \"parameters\": [{\"name\": \"rsi_period\", \"min\": 5, \"max\": 25, \"step\": 10}],\n  \"result\": \"Best = 15\"\n}\n{\n  \"stage_2\": \"Narrow range, small steps\",\n  \"parameters\": [{\"name\": \"rsi_period\", \"min\": 12, \"max\": 18, \"step\": 2}],\n  \"result\": \"Best = 14\"\n}\n```\n\n3. **Reduce Ranges Based on Domain Knowledge**:\n- RSI: 10-20 instead of 2-50\n- Stop Loss: 3-7% instead of 1-20%\n- Only test realistic values\n\n**Example Combination Calculation**:\n\n```python\n# 2 parameters\nrsi_values = (20 - 10) / 5 + 1  # = 3 values [10, 15, 20]\nstop_values = (0.07 - 0.03) / 0.02 + 1  # = 3 values [0.03, 0.05, 0.07]\ntotal_combinations = 3 \u00d7 3 = 9  # Manageable\n\n# 4 parameters (DANGER!)\nrsi = 5 values\nstop = 5 values\nma_period = 5 values\nposition_size = 4 values\ntotal_combinations = 5 \u00d7 5 \u00d7 5 \u00d7 4 = 500  # Expensive!\n```",
      "tags": [
        "strategies",
        "grid_search",
        "optimization"
      ],
      "priority": 1,
      "related_sections": [
        "parameter_grids",
        "cost_estimation"
      ]
    },
    {
      "id": "parameter_grids",
      "title": "Parameter Grid Setup",
      "content": "**Grid Definition Format**\n\n```json\n{\n  \"parameters\": [\n    {\n      \"name\": \"rsi_period\",\n      \"min\": 10,\n      \"max\": 20,\n      \"step\": 5\n    },\n    {\n      \"name\": \"stop_loss\",\n      \"min\": 0.03,\n      \"max\": 0.07,\n      \"step\": 0.02\n    }\n  ],\n  \"target\": \"TotalPerformance.PortfolioStatistics.SharpeRatio\",\n  \"targetTo\": \"max\",\n  \"nodeType\": \"O2-8\",\n  \"parallelNodes\": 2\n}\n```\n\n**Calculating Combinations**\n\nFor each parameter: `(max - min) / step + 1`\nTotal combinations: Product of all parameter counts\n\n**Example**:\n```python\n# Parameter 1: rsi_period\nvalues_1 = (20 - 10) / 5 + 1 = 3  # [10, 15, 20]\n\n# Parameter 2: stop_loss\nvalues_2 = (0.07 - 0.03) / 0.02 + 1 = 3  # [0.03, 0.05, 0.07]\n\n# Total combinations\ntotal = 3 \u00d7 3 = 9 backtests\n```\n\n**Parameter Name Requirements**:\n- Must match EXACTLY to strategy code (case-sensitive)\n- Strategy code: `self.rsi_period = self.GetParameter(\"rsi_period\")`\n- Config file: `\"name\": \"rsi_period\"`\n\n**Best Practices**:\n\n1. **Start Small** (3-6 combinations to test system)\n```json\n{\n  \"parameters\": [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 10}  # 2 values\n  ]\n}\n```\n\n2. **Keep Total < 100** for grid search\n- 2 params \u00d7 5 values = 25 combos \u2705\n- 3 params \u00d7 5 values = 125 combos \u274c\n\n3. **Use Meaningful Step Sizes** (not too fine)\n- RSI period: step=5 (not step=1)\n- Stop loss: step=0.02 (not step=0.001)\n\n4. **Test One Parameter at a Time First**\n- Optimize RSI \u2192 Find best value\n- Then optimize stop_loss with fixed RSI\n\n5. **Check for Boundary Optima**\n- If optimal = max value, expand grid upward\n- If optimal = min value, expand grid downward\n\n**Common Targets**:\n- Sharpe Ratio: `TotalPerformance.PortfolioStatistics.SharpeRatio`\n- Total Return: `TotalPerformance.PortfolioStatistics.TotalNetProfit`\n- Max Drawdown: `TotalPerformance.PortfolioStatistics.Drawdown`\n\n**Node Types** (compute resources):\n- `O2-8`: 2GB RAM, 8 cores (~$0.02/min) - Default\n- `O4-12`: 4GB RAM, 12 cores (~$0.04/min) - Faster\n- `O8-16`: 8GB RAM, 16 cores (~$0.08/min) - Fastest\n\n**Parallel Nodes**:\n- 2 nodes: Recommended default\n- 4 nodes: Faster but 2x cost\n- 6 nodes: Maximum, expensive",
      "tags": [
        "parameters",
        "grid",
        "setup"
      ],
      "priority": 1,
      "related_sections": [
        "optimization_strategies",
        "cost_estimation"
      ]
    },
    {
      "id": "decision_criteria",
      "title": "Phase 4 Decision Criteria",
      "content": "**Improvement Calculation**\n\n`improvement = (optimized_sharpe - baseline_sharpe) / baseline_sharpe`\n\n**Automatic Decision Thresholds**\n\n**USE_BASELINE** (Improvement < 5%)\n- Optimization didn't help significantly\n- Use original baseline parameters from /qc-backtest\n- May indicate strategy already well-tuned\n- **Next Step**: Skip to /qc-validate with baseline parameters\n\n**PROCEED_TO_VALIDATION** (Improvement 5-30%) \u2705\n- Good improvement, likely robust\n- Sweet spot for optimization\n- Improvement meaningful but not suspicious\n- **Next Step**: Run /qc-validate with optimized parameters\n\n**ESCALATE_TO_HUMAN** (Improvement > 30%) \u26a0\ufe0f\n- Too large - likely overfitting\n- Parameters curve-fit to noise\n- Won't generalize to out-of-sample data\n- **Next Step**: Human review required before proceeding\n\n**Examples**:\n\n```python\n# Example 1: Minimal improvement\nbaseline_sharpe = 0.80\noptimized_sharpe = 0.82\nimprovement = (0.82 - 0.80) / 0.80 = 0.025 = 2.5%\n\nDecision: USE_BASELINE\nReason: \"2.5% < 5% threshold - not worth the complexity\"\nNext: /qc-validate with baseline params\n```\n\n```python\n# Example 2: Good improvement (IDEAL)\nbaseline_sharpe = 0.80\noptimized_sharpe = 0.96\nimprovement = (0.96 - 0.80) / 0.80 = 0.20 = 20%\n\nDecision: PROCEED_TO_VALIDATION \u2705\nReason: \"20% in sweet spot (5-30%) - proceed\"\nNext: /qc-validate with optimized params\n```\n\n```python\n# Example 3: Excessive improvement (SUSPICIOUS)\nbaseline_sharpe = 0.80\noptimized_sharpe = 1.20\nimprovement = (1.20 - 0.80) / 0.80 = 0.50 = 50%\n\nDecision: ESCALATE_TO_HUMAN \u26a0\ufe0f\nReason: \"50% > 30% threshold - likely overfitting\"\nRed Flags:\n- Check trade count (did it drop significantly?)\n- Check equity curve (sharp spikes?)\n- Check parameters (unrealistic values?)\n```\n\n**Additional Checks**:\n\n1. **Trade Count Change**:\n```python\nif optimized_trades < baseline_trades * 0.5:\n    warning = \"Trade count dropped > 50% - may be overfitting\"\n```\n\n2. **Parameter Reasonableness**:\n```python\nif stop_loss < 0.005:  # 0.5%\n    warning = \"Stop loss too tight - unrealistic\"\nif position_size > 0.95:  # 95%\n    warning = \"Position size too large - risky\"\n```\n\n3. **Boundary Check**:\n```python\nif optimal_rsi == max_rsi or optimal_rsi == min_rsi:\n    warning = \"Optimal at grid boundary - expand and re-optimize\"\n```",
      "tags": [
        "decisions",
        "thresholds",
        "phase4"
      ],
      "priority": 1,
      "related_sections": [
        "overfitting_detection",
        "workflow_overview"
      ]
    },
    {
      "id": "cost_estimation",
      "title": "Cost Estimation and Management",
      "content": "**QuantConnect Cloud Pricing**\n\n**Node Types** (compute resources):\n- `O2-8`: 2GB RAM, 8 cores (~$0.02/min)\n- `O4-12`: 4GB RAM, 12 cores (~$0.04/min)\n- `O8-16`: 8GB RAM, 16 cores (~$0.08/min)\n\n**Cost Formula**:\n```python\ncost = combinations \u00d7 backtest_time \u00d7 node_cost \u00d7 parallel_nodes\n```\n\n**Estimating Costs**\n\n```bash\n# Via CLI (recommended)\nvenv/bin/python SCRIPTS/qc_optimize.py run \\\n  --config optimization_params.json \\\n  --estimate-only\n```\n\n**Output Example**:\n```\n\ud83d\udcca Configuration:\n   Parameters: 2\n   Combinations: 9\n   Baseline Sharpe: 0.850\n\n\ud83d\udcb0 Estimating cost...\n   Estimated cost: $3.50\n   Estimated time: 18 minutes\n   Node type: O2-8\n   Parallel nodes: 2\n```\n\n**Cost Factors**:\n\n1. **Number of Combinations** (biggest factor)\n   - 10 combos: $1-3\n   - 50 combos: $5-15\n   - 100 combos: $15-30\n\n2. **Backtest Duration** (years of data)\n   - 1 year: Fast, cheap\n   - 5 years: Standard, moderate cost\n   - 10+ years: Slow, expensive\n\n3. **Strategy Complexity**\n   - Simple (1-2 indicators): Fast\n   - Medium (5-10 indicators): Standard\n   - Complex (large universe, ML): Slow\n\n4. **Node Type**\n   - O2-8: Slowest but cheapest\n   - O4-12: 2x faster, 2x cost\n   - O8-16: 4x faster, 4x cost\n\n5. **Parallel Nodes**\n   - 1 node: Slowest, cheapest\n   - 2 nodes: Recommended balance\n   - 4 nodes: Faster, higher cost\n\n**Typical Costs**:\n\n**Small Grid** (10 combinations, 3 years, O2-8):\n- Cost: $1-3\n- Time: 10-20 minutes\n- Use case: Initial testing\n\n**Medium Grid** (50 combinations, 5 years, O2-8):\n- Cost: $5-15\n- Time: 50-100 minutes\n- Use case: Standard optimization\n\n**Large Grid** (200 combinations, 10 years, O4-12):\n- Cost: $40-100\n- Time: 100-200 minutes\n- Use case: Comprehensive search\n\n**Cost Optimization Strategies**:\n\n1. **Test on Shorter Period First**\n```python\n# Quick test: 1 year\ntest_period = {'start': '2023-01-01', 'end': '2023-12-31'}\ncost \u2248 $2\n\n# If results good, run full period\nfull_period = {'start': '2019-01-01', 'end': '2023-12-31'}\ncost \u2248 $10\n```\n\n2. **Start with Coarse Grid**\n```python\n# Coarse: 9 combinations\nstep = 10  # Large steps\ncost \u2248 $3\n\n# Fine: 100 combinations (only if coarse looks good)\nstep = 2  # Small steps\ncost \u2248 $30\n```\n\n3. **Use O2-8 Unless Urgent**\n- O2-8: Good for overnight runs\n- O4-12: Use when need results faster\n- O8-16: Only for time-critical work\n\n4. **Reduce Parallel Nodes if Not Urgent**\n- 1 node: Half the cost, twice the time\n- 2 nodes: Recommended default\n- 4 nodes: Only if need speed",
      "tags": [
        "cost",
        "pricing",
        "estimation"
      ],
      "priority": 2,
      "related_sections": [
        "optimization_strategies",
        "parameter_grids"
      ]
    },
    {
      "id": "overfitting_detection",
      "title": "Overfitting Detection in Optimization",
      "content": "**Red Flags for Overfitting**\n\n**1. Excessive Improvement (> 30%)**\n```python\nbaseline_sharpe = 0.8\noptimized_sharpe = 1.3\nimprovement = 62.5%  # TOO HIGH!\n\nProblem: Parameters likely fit to random noise\nWon't Work: Out-of-sample performance will degrade\n```\n\n**2. Parameter at Grid Boundary**\n```python\ngrid = {\"rsi_period\": {\"min\": 10, \"max\": 30, \"step\": 10}}\noptimal = 30  # At maximum!\n\nProblem: True optimum may be outside grid\nFix: Expand grid (test 30-50) and re-optimize\n```\n\n**3. Unrealistic Parameter Values**\n```python\nstop_loss = 0.001  # 0.1% - TOO TIGHT\nposition_size = 0.99  # 99% - TOO LARGE\nrsi_period = 2  # TOO SHORT\n\nProblem: Parameters don't make logical sense\nCheck: Do values align with domain knowledge?\n```\n\n**4. Equity Curve Shape Change**\n```\nBaseline Curve:     Optimized Curve:\n    /\u203e\u203e\\            /|  Sharp spike\n   /    \\          / |  \n  /      \\        /  |___ Flat after\n /        \\      /\n/          \\    /\n\nProblem: Fit to specific events, not robust pattern\n```\n\n**5. Significant Trade Count Change**\n```python\nbaseline_trades = 120\noptimized_trades = 15  # 87.5% reduction!\n\nProblem: Fewer trades = less statistical reliability\nLikely: Parameters filter to only \"perfect\" trades\nReality: Perfect trades won't repeat out-of-sample\n```\n\n**6. Win Rate Too High**\n```python\nbaseline_win_rate = 0.45  # 45% (realistic)\noptimized_win_rate = 0.85  # 85% (suspicious!)\n\nProblem: Unrealistically high win rate\nLikely: Overfit to past winning patterns\n```\n\n**Prevention Strategies**\n\n**1. Limit Parameter Ranges**\n```python\n# \u274c BAD: Too wide\n{\"stop_loss\": {\"min\": 0.001, \"max\": 0.50}}  # 0.1% to 50%\n\n# \u2705 GOOD: Realistic range\n{\"stop_loss\": {\"min\": 0.03, \"max\": 0.07}}  # 3% to 7%\n```\n\n**2. Keep Grids Coarse**\n```python\n# \u274c BAD: Too fine\n{\"rsi_period\": {\"min\": 10, \"max\": 30, \"step\": 1}}  # 21 values\n\n# \u2705 GOOD: Coarse steps\n{\"rsi_period\": {\"min\": 10, \"max\": 30, \"step\": 5}}  # 5 values\n```\n\n**3. Require Minimum Trade Count**\n```python\nif optimized_trades < 30:\n    decision = \"ESCALATE_TO_HUMAN\"\n    reason = \"Too few trades for statistical significance\"\n```\n\n**4. Check Logical Consistency**\n```python\nif best_params['stop_loss'] < 0.01:  # < 1%\n    warning = \"Stop loss unrealistically tight\"\n\nif best_params['rsi_period'] < 5:  # < 5 periods\n    warning = \"RSI period too short for meaningful signal\"\n```\n\n**5. Always Validate Out-of-Sample (Phase 5)**\n```\nOptimization alone CANNOT prove robustness.\nMUST run /qc-validate to test out-of-sample.\nTrue test: Does it work on UNSEEN data?\n```\n\n**When to Suspect Overfitting**:\n\n\u2705 **Likely Robust**:\n- Improvement: 10-20%\n- Trade count: Similar to baseline\n- Parameters: Logical values\n- Win rate: 40-55%\n\n\u26a0\ufe0f **Investigate Further**:\n- Improvement: 25-35%\n- Trade count: -30% to -50%\n- Parameters: At grid boundaries\n- Win rate: 60-70%\n\n\u274c **Likely Overfit**:\n- Improvement: > 40%\n- Trade count: < 50% of baseline\n- Parameters: Extreme/unrealistic\n- Win rate: > 75%",
      "tags": [
        "overfitting",
        "validation",
        "red_flags"
      ],
      "priority": 1,
      "related_sections": [
        "decision_criteria",
        "parameter_grids"
      ]
    },
    {
      "id": "qc_coding_standards",
      "title": "QuantConnect Coding Standards",
      "content": "**Essential QC Platform Coding Rules**\n\nWhen writing or modifying strategy code for optimization, follow these QuantConnect platform standards.\n\n**Complete Reference**: See HELP/qc_guide.json for full specification\n\n---\n\n## Syntax and Naming\n\n\u2705 **CORRECT**:\n```python\n# Variables and functions: snake_case\ndef calculate_delta_ratio(symbol, expiry):\n    \"\"\"Calculate delta ratio for option.\"\"\"\n    rsi_period = self.GetParameter(\"rsi_period\", 14)\n    return ratio\n\n# Constants: UPPERCASE\nMINUTE = 60\nDAILY = \"1d\"\nMAX_HOLDINGS = 10\n```\n\n\u274c **WRONG - AVOID PascalCase**:\n```python\ndef CalculateDeltaRatio(Symbol, Expiry):  # PascalCase - WRONG (legacy QC)\n    RSI_Period = self.GetParameter(\"RSI_Period\", 14)  # Mixed case - WRONG\n\nclass MyStrategy:  # PascalCase class - AVOID (use snake_case)\n    pass\n```\n\n**Rules**:\n- **ALWAYS** use `snake_case` for variables, functions, and classes\n- **ONLY** use `UPPERCASE` for constants (MINUTE, DAILY, MAX_POSITIONS, etc.)\n- **NEVER** use `PascalCase` (legacy QuantConnect convention - avoid at all costs)\n- Follow PEP8 (4 spaces, no tabs)\n- Triple-quoted docstrings\n\n---\n\n## Environment Compatibility\n\n\u2705 **ALLOWED** imports:\n```python\nfrom AlgorithmImports import *\nimport pandas as pd\nimport numpy as np\nfrom sklearn import linear_model\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n```\n\n\u274c **FORBIDDEN** imports:\n```python\nimport requests  # Not available in QC\nimport yfinance  # Not available in QC\nfrom dotenv import load_env  # Not available in QC\nimport plotly  # Not available in QC\nimport os  # File operations not allowed\n```\n\n**Rules**:\n- No file I/O operations\n- No subprocess or os.system calls\n- No async/await or multithreading\n- QC runtime is synchronous single-threaded\n\n---\n\n## Algorithm Structure\n\n\u2705 **CORRECT**:\n```python\nclass MyStrategy(QCAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2019, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Define parameters in Initialize\n        self.rsi_period = self.GetParameter(\"rsi_period\", 14)\n        self.stop_loss = self.GetParameter(\"stop_loss\", 0.05)\n        \n        # Add securities in Initialize\n        self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n        \n        # Create indicators in Initialize\n        self.rsi = self.RSI(\"SPY\", self.rsi_period)\n    \n    def OnData(self, data):\n        if self.IsWarmingUp:\n            return\n        \n        # Use self.Debug(), not print()\n        self.Debug(f\"RSI: {self.rsi.Current.Value:.2f}\")\n```\n\n\u274c **WRONG**:\n```python\nclass MyStrategy(QCAlgorithm):\n    def OnData(self, data):\n        # WRONG: Adding securities in OnData\n        self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n        \n        # WRONG: Using print()\n        print(\"RSI:\", self.rsi.Current.Value)\n        \n        # WRONG: Not checking IsWarmingUp\n        if self.rsi.Current.Value < 30:\n            self.SetHoldings(\"SPY\", 1.0)\n```\n\n**Rules**:\n- Define dates, cash, securities in `Initialize()`\n- Create indicators in `Initialize()`\n- Use `self.Debug()`, not `print()`\n- Guard with `if self.IsWarmingUp: return`\n- Never add securities in `OnData()`\n\n---\n\n## Parameter Definition for Optimization\n\n\u2705 **CORRECT**:\n```python\ndef Initialize(self):\n    # Define parameters with defaults\n    self.rsi_period = self.GetParameter(\"rsi_period\", 14)\n    self.stop_loss = self.GetParameter(\"stop_loss\", 0.05)\n    self.position_size = self.GetParameter(\"position_size\", 0.50)\n    \n    # Use parameters in indicators\n    self.rsi = self.RSI(\"SPY\", self.rsi_period)\n```\n\nCorresponding optimization_params.json:\n```json\n{\n  \"parameters\": [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5},\n    {\"name\": \"stop_loss\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}\n  ]\n}\n```\n\n**CRITICAL**: Parameter names in JSON **MUST match exactly** (case-sensitive)\n\n\u274c **WRONG**:\n```python\n# Strategy code\nself.rsi_period = self.GetParameter(\"rsi_period\", 14)\n```\n\n```json\n# Optimization params - WRONG case\n{\"name\": \"RSI_Period\", \"min\": 10, \"max\": 20}\n```\n\nThis will fail - parameter names don't match!\n\n---\n\n## Logging Standards\n\n\u2705 **CORRECT**:\n```python\nself.Debug(f\"Signal: {signal}, RSI: {self.rsi.Current.Value:.2f}\")\nself.Log(f\"Position opened: {self.Portfolio.TotalPortfolioValue}\")\nself.Error(f\"Failed to execute trade: {ex}\")\n```\n\n\u274c **WRONG**:\n```python\nprint(\"Signal:\", signal)  # WRONG - use self.Debug()\nlogging.info(\"Position opened\")  # WRONG - no external logging\n```\n\n**Rules**:\n- `self.Debug()` - Quick logging (throttle in OnData)\n- `self.Log()` - Standard logging\n- `self.Error()` - Exceptions\n- Never use `print()` or external logging frameworks\n\n---\n\n## Data Access\n\n\u2705 **CORRECT**:\n```python\ndef Initialize(self):\n    # Warm up indicators\n    self.SetWarmup(100)\n    self.rsi = self.RSI(\"SPY\", 14)\n\ndef OnData(self, data):\n    if self.IsWarmingUp:\n        return  # Don't trade during warmup\n    \n    if self.rsi.IsReady:\n        rsi_value = self.rsi.Current.Value\n```\n\n\u274c **WRONG**:\n```python\ndef OnData(self, data):\n    # WRONG: Not checking IsWarmingUp\n    rsi_value = self.rsi.Current.Value  # May not be ready!\n    \n    # WRONG: Expensive history call in loop\n    for symbol in self.symbols:\n        history = self.History([symbol], 100, Resolution.Minute)\n```\n\n**Rules**:\n- Always check `self.IsWarmingUp`\n- Always check `indicator.IsReady`\n- Avoid `History()` calls in loops\n- Prefetch data outside loops\n\n---\n\n## Quick Checklist\n\nBefore running optimization, verify:\n\n- \u2705 `snake_case` for variables/functions/classes, `UPPERCASE` for constants\n- \u2705 Valid QC imports only (no requests, yfinance, etc.)\n- \u2705 `Initialize()` defines dates, cash, securities\n- \u2705 No file I/O or async\n- \u2705 `OnData()` guards with `IsWarmingUp`\n- \u2705 Use `self.Debug()` not `print()`\n- \u2705 Parameter names match exactly between code and JSON\n- \u2705 Indicators created in `Initialize()`\n- \u2705 No emojis in code\n\n**Full Specification**: HELP/qc_guide.json",
      "tags": [
        "coding_standards",
        "qc_platform",
        "best_practices"
      ],
      "priority": 1,
      "related_sections": [
        "parameter_grids",
        "common_errors"
      ]
    },
    {
      "id": "common_errors",
      "title": "Common Errors and Fixes",
      "content": "**Error: \"No baseline backtest found\"**\n\n**Cause**: iteration_state.json missing backtest results\n\n**Fix**:\n```bash\n# Run Phase 3 first\n/qc-backtest\n\n# Verify backtest_id exists\ncat iteration_state.json | jq '.backtest_results.backtest_id'\n```\n\n**Error: \"No project_id in iteration_state.json\"**\n\n**Cause**: Project not created yet\n\n**Fix**:\n```bash\n# Initialize if needed\n/qc-init\n\n# Run backtest (creates project)\n/qc-backtest\n\n# Verify project_id\ncat iteration_state.json | jq '.project.project_id'\n```\n\n**Error: \"Grid too large (> 100 combinations)\"**\n\n**Cause**: Too many parameter combinations\n\n**Fix 1 - Reduce Ranges**:\n```json\n// Before: 125 combinations\n{\n  \"parameters\": [\n    {\"name\": \"rsi\", \"min\": 10, \"max\": 30, \"step\": 5},  // 5 values\n    {\"name\": \"ma\", \"min\": 20, \"max\": 100, \"step\": 20},  // 5 values\n    {\"name\": \"stop\", \"min\": 0.02, \"max\": 0.10, \"step\": 0.02}  // 5 values\n  ]\n}  // 5 \u00d7 5 \u00d7 5 = 125\n\n// After: 27 combinations\n{\n  \"parameters\": [\n    {\"name\": \"rsi\", \"min\": 10, \"max\": 20, \"step\": 5},  // 3 values\n    {\"name\": \"ma\", \"min\": 40, \"max\": 80, \"step\": 20},  // 3 values\n    {\"name\": \"stop\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}  // 3 values\n  ]\n}  // 3 \u00d7 3 \u00d7 3 = 27\n```\n\n**Fix 2 - Multi-Stage Optimization**:\n```bash\n# Stage 1: Optimize RSI only\n{\"parameters\": [{\"name\": \"rsi\", \"min\": 10, \"max\": 30, \"step\": 5}]}\n# Result: best_rsi = 15\n\n# Stage 2: Fix RSI, optimize others\n{\"parameters\": [\n  {\"name\": \"ma\", \"min\": 20, \"max\": 100, \"step\": 20},\n  {\"name\": \"stop\", \"min\": 0.02, \"max\": 0.10, \"step\": 0.02}\n]}\n```\n\n**Fix 3 - Optimize One at a Time**:\n```bash\n# Run 1: Optimize RSI (5 combos)\n# Run 2: Optimize MA (5 combos)\n# Run 3: Optimize stop (5 combos)\n# Total: 15 combos instead of 125\n```\n\n**Error: \"Insufficient funds\"**\n\n**Cause**: QuantConnect account balance too low\n\n**Fix**:\n1. Add funds to QC account\n2. OR reduce combinations (smaller grid)\n3. OR use cheaper node type (O2-8)\n\n**Error: \"Optimization timeout\"**\n\n**Cause**: Taking longer than default timeout (30 min)\n\n**Fix**:\n```python\n# Increase timeout to 60 minutes\napi.wait_for_optimization(optimization_id, timeout=3600)\n\n# Or use CLI with longer timeout\nqc_optimize.py run --config params.json --timeout 3600\n```\n\n**Error: \"Parameter not found in strategy\"**\n\n**Cause**: Parameter name doesn't match strategy code\n\n**Fix**:\n```python\n# Strategy code (must match exactly)\nself.rsi_period = self.GetParameter(\"rsi_period\", 14)\n\n# Config file (exact match, case-sensitive)\n{\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5}\n\n# \u274c WRONG\n{\"name\": \"RSI_Period\"}  # Wrong case\n{\"name\": \"rsi\"}          # Missing \"_period\"\n```\n\n**Error: \"API authentication failed\"**\n\n**Cause**: Missing or invalid QC credentials\n\n**Fix**:\n```bash\n# Check .env file exists\ncat .env\n\n# Should contain:\nQUANTCONNECT_USER_ID=your_user_id\nQUANTCONNECT_API_TOKEN=your_api_token\n\n# Get credentials from:\n# https://www.quantconnect.com/account\n```\n\n**Error: \"Project not found\"**\n\n**Cause**: project_id in iteration_state.json doesn't exist on QC\n\n**Fix**:\n```bash\n# Verify project exists\npython -c \"from qc_api import QuantConnectAPI; \\\n           api = QuantConnectAPI(); \\\n           print(api.list_projects())\"\n\n# If project deleted, run /qc-backtest to create new one\n```",
      "tags": [
        "errors",
        "troubleshooting",
        "fixes"
      ],
      "priority": 2,
      "related_sections": [
        "workflow_overview",
        "qc_platform_access"
      ]
    }
  ],
  "examples": [
    {
      "title": "Small Grid Optimization (Recommended Start)",
      "description": "2 parameters, 9 combinations - good for testing",
      "code": "{\n  \"parameters\": [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 20, \"step\": 5},\n    {\"name\": \"stop_loss\", \"min\": 0.03, \"max\": 0.07, \"step\": 0.02}\n  ],\n  \"target\": \"TotalPerformance.PortfolioStatistics.SharpeRatio\",\n  \"targetTo\": \"max\",\n  \"nodeType\": \"O2-8\",\n  \"parallelNodes\": 2\n}",
      "output": "Combinations: 3 \u00d7 3 = 9\nEstimated cost: $2-5\nEstimated time: 18-36 minutes\nRecommended: Good starting point",
      "tags": [
        "small",
        "grid",
        "example"
      ]
    },
    {
      "title": "Multi-Stage Optimization",
      "description": "Optimize in stages to manage large parameter spaces efficiently",
      "code": "# Stage 1: Coarse grid (wide range, large steps)\n{\n  \"parameters\": [\n    {\"name\": \"rsi_period\", \"min\": 10, \"max\": 30, \"step\": 10},\n    {\"name\": \"stop_loss\", \"min\": 0.02, \"max\": 0.08, \"step\": 0.03}\n  ]\n}\n# Result: rsi_period=20, stop_loss=0.05 best\n# Cost: 9 combinations\n\n# Stage 2: Fine-tune around best (narrow range, small steps)\n{\n  \"parameters\": [\n    {\"name\": \"rsi_period\", \"min\": 15, \"max\": 25, \"step\": 5},\n    {\"name\": \"stop_loss\", \"min\": 0.04, \"max\": 0.06, \"step\": 0.01}\n  ]\n}\n# Result: rsi_period=18, stop_loss=0.048 optimal\n# Cost: 9 combinations\n\n# Total: 18 backtests vs 81 for full fine grid",
      "output": "Stage 1: 9 combinations ($3)\nStage 2: 9 combinations ($3)\nTotal: $6 vs $27 for full fine grid\nSavings: 78% cost reduction",
      "tags": [
        "multi-stage",
        "optimization",
        "example"
      ]
    },
    {
      "title": "Good Optimization Result (PROCEED_TO_VALIDATION)",
      "description": "20% improvement - sweet spot, proceed to validation",
      "code": "Baseline (from /qc-backtest):\n  Sharpe: 0.85\n  Trades: 89\n  Win Rate: 47%\n\nOptimization Result:\n  Sharpe: 1.02\n  Trades: 94\n  Win Rate: 51%\n\nImprovement: (1.02 - 0.85) / 0.85 = 20%\n\nBest Parameters:\n  rsi_period: 15\n  stop_loss: 0.05",
      "output": "Decision: PROCEED_TO_VALIDATION \u2705\nReasoning: 20% in sweet spot (5-30%)\nTrade count stable (94 vs 89)\nWin rate reasonable (51%)\n\nNext Step: /qc-validate with optimized parameters",
      "tags": [
        "good",
        "result",
        "validation"
      ]
    },
    {
      "title": "Suspicious Result (ESCALATE_TO_HUMAN)",
      "description": "Excessive improvement and red flags - human review needed",
      "code": "Baseline (from /qc-backtest):\n  Sharpe: 0.80\n  Trades: 120\n  Win Rate: 44%\n\nOptimization Result:\n  Sharpe: 1.50\n  Trades: 18\n  Win Rate: 83%\n\nImprovement: (1.50 - 0.80) / 0.80 = 87.5%",
      "output": "Decision: ESCALATE_TO_HUMAN \u26a0\ufe0f\n\nRed Flags:\n  \u274c 87.5% improvement >> 30% threshold\n  \u274c Trade count dropped 85% (120 \u2192 18)\n  \u274c Win rate suspiciously high (83%)\n\nLikely: Overfitting to random events\n\nNext Step: Human review required\n- Review equity curve\n- Check parameter reasonableness\n- Consider simpler strategy",
      "tags": [
        "suspicious",
        "overfitting",
        "escalate"
      ]
    }
  ],
  "faqs": [
    {
      "question": "Can I optimize without running /qc-backtest first?",
      "answer": "No. QC API requires a baseline backtest in the project. Optimization compares results against this baseline. Workflow: /qc-init \u2192 /qc-backtest \u2192 /qc-optimize. Always run /qc-backtest before /qc-optimize.",
      "tags": [
        "prerequisites",
        "workflow"
      ],
      "related_sections": [
        "workflow_overview",
        "qc_platform_access"
      ]
    },
    {
      "question": "How many parameters should I optimize at once?",
      "answer": "Start with 1-2 parameters. Combinations grow exponentially: 2 params \u00d7 5 values = 25 combos (manageable). 4 params \u00d7 5 values = 625 combos (expensive). For 3+ parameters, use multi-stage optimization or optimize one at a time.",
      "tags": [
        "parameters",
        "best_practices"
      ],
      "related_sections": [
        "parameter_grids",
        "optimization_strategies"
      ]
    },
    {
      "question": "Optimization improved Sharpe from 0.9 to 1.3 (44%) - should I use it?",
      "answer": "ESCALATE_TO_HUMAN. 44% > 30% threshold indicates likely overfitting. Parameters probably fit to random noise, won't work out-of-sample. Check: trade count change, parameter reasonableness, equity curve shape. Consider using baseline or simpler optimization.",
      "tags": [
        "overfitting",
        "decisions"
      ],
      "related_sections": [
        "decision_criteria",
        "overfitting_detection"
      ]
    },
    {
      "question": "What if optimal parameter is at grid boundary?",
      "answer": "Expand grid in that direction and re-optimize. Example: If rsi_period=30 is best and max=30, try grid 20-40. Boundary optima suggest true optimum outside current grid. Always check and expand when needed.",
      "tags": [
        "parameters",
        "boundaries"
      ],
      "related_sections": [
        "parameter_grids",
        "overfitting_detection"
      ]
    },
    {
      "question": "How long does optimization take and how much does it cost?",
      "answer": "Depends on combinations and complexity. Rough estimate: 1-2 minutes per combination. 50 combos \u2248 50-100 minutes, $5-15. Use --estimate-only flag to get precise cost before running. Start with small grids (< 20 combos) to test.",
      "tags": [
        "time",
        "cost"
      ],
      "related_sections": [
        "cost_estimation",
        "parameter_grids"
      ]
    },
    {
      "question": "Can I create a new project for optimization?",
      "answer": "NO. NEVER create new project in optimization phase. MUST use project_id from iteration_state.json (created by /qc-backtest). Creating new project will fail - QC needs baseline backtest to compare against. Always read project_id from iteration_state.json.",
      "tags": [
        "project_id",
        "critical",
        "workflow"
      ],
      "related_sections": [
        "workflow_overview",
        "qc_platform_access"
      ]
    }
  ],
  "related_tools": [
    "qc_backtest",
    "qc_validate",
    "decision_framework",
    "backtesting_analysis"
  ],
  "metadata": {
    "created": "2025-11-13",
    "updated": "2025-11-13",
    "version": "2.3.1",
    "authors": [
      "Claude"
    ],
    "skill": "quantconnect-optimization",
    "changelog": "v2.3.1: Corrected naming rules - NEVER use PascalCase (legacy), use snake_case everywhere except UPPERCASE constants. v2.3.0: Added QC coding standards. v2.2.0: Added CLI/API reference"
  }
}