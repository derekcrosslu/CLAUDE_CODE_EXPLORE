{
  "title": "Claude Code Platform Specification Guide",
  "version": "1.1.0",
  "description": "Comprehensive execution and coding standard for Claude Code to generate, validate, and maintain error-free Python and QuantConnect-compatible code within the Letta AI framework. Optimized for Claude\u2019s retrieval and reasoning layer.",
  "metadata": {
    "language": "Python",
    "target_environment": "QuantConnect Claude Execution Environment (Python 3.8)",
    "compatibility": [
      "Claude Code",
      "Letta AI Runtime",
      "QuantConnect Cloud"
    ],
    "author": "System Specification derived from Derek Cross requirements"
  },
  "sections": [
    {
      "id": "syntax_and_naming",
      "title": "Syntax and Naming Rules",
      "rules": [
        "Use snake_case for all variable, function, and class names.",
        "Use UPPERCASE for constants (MINUTE, DAILY, MAX_POSITIONS, etc.).",
        "NEVER use PascalCase (legacy QuantConnect convention - avoid at all costs).",
        "Do not mix naming conventions in a single file.",
        "Ensure docstrings are triple-quoted and concise.",
        "Follow PEP8 spacing and indentation (4 spaces, no tabs)."
      ],
      "examples": [
        {
          "good": "def calculate_delta_ratio(symbol, expiry):\n    MAX_CONTRACTS = 10\n    rsi_period = 14",
          "bad": "def CalculateDeltaRatio(Symbol, Expiry):  # PascalCase - WRONG (legacy)\n    class MyStrategy:  # PascalCase class - AVOID"
        }
      ],
      "tags": [
        "style",
        "syntax",
        "naming",
        "pep8"
      ]
    },
    {
      "id": "environment_compatibility",
      "title": "Environment Compatibility",
      "rules": [
        "Ensure code compiles and executes inside the QuantConnect Claude execution environment, not local Python.",
        "Avoid imports not preinstalled in QC. Allowed: pandas, numpy, sklearn, matplotlib, scipy, hmmlearn.",
        "Disallowed: requests, yfinance, ta, dotenv, plotly, openai, whisper, aio libraries.",
        "Never use local file operations, subprocess, or os.system calls.",
        "No async or multithreading \u2014 QC runtime is synchronous single-threaded."
      ],
      "examples": [
        {
          "good": "from AlgorithmImports import *",
          "bad": "import os; os.system('echo hello')"
        }
      ],
      "tags": [
        "environment",
        "compatibility",
        "dependencies"
      ]
    },
    {
      "id": "imports_and_dependencies",
      "title": "Imports and Dependencies",
      "rules": [
        "Use fully qualified imports from AlgorithmImports.",
        "Avoid circular imports and redundant statements.",
        "Keep imports grouped and alphabetized for clarity."
      ],
      "examples": [
        {
          "good": "from AlgorithmImports import *",
          "bad": "import AlgorithmImports, sys, AlgorithmImports"
        }
      ],
      "tags": [
        "imports",
        "dependencies"
      ]
    },
    {
      "id": "algorithm_structure",
      "title": "Algorithm Initialization and Structure",
      "rules": [
        "Always define initialize(self) with set_start_date, set_end_date, set_cash, and add_equity or add_option.",
        "Never access attributes before security creation.",
        "Do not assign objects dynamically inside on_data; define them in initialize.",
        "Avoid print(); use self.debug() or self.log()."
      ],
      "examples": [
        {
          "good": "def initialize(self): self.spy = self.add_equity('SPY', Resolution.Minute)",
          "bad": "def on_data(self, data): self.spy = self.add_equity('SPY')"
        }
      ],
      "tags": [
        "structure",
        "lifecycle",
        "initialize"
      ]
    },
    {
      "id": "option_chains_and_strategies",
      "title": "Option Chains and Strategy Combos",
      "rules": [
        "Always subscribe to the underlying before adding options.",
        "Access data.option_chains only after confirming it's non-empty.",
        "Convert chain to list before filtering or sorting.",
        "Use datetime.date() for expiry comparisons.",
        "Use OptionStrategies helpers for multi-leg trades (calendar, vertical, condor, etc.).",
        "Check leg direction carefully: positive quantity = long, negative = short.",
        "Refresh contracts from live chain every trade; never reuse old references.",
        "Guard on_data against missing Greeks or implied volatility.",
        "Execute combos via add_option_strategy(), not market_order().",
        "Use on_order_event to confirm fills and maintain self.active_positions dict."
      ],
      "examples": [
        {
          "good": "strategy = OptionStrategies.calendar_spread(symbol, near_expiry, far_expiry, strike)\nself.add_option_strategy(strategy, 1)",
          "bad": "self.market_order(contract.symbol, 1)"
        }
      ],
      "tags": [
        "options",
        "strategies",
        "calendar_spread",
        "combos"
      ]
    },
    {
      "id": "data_access_and_indicators",
      "title": "Data Access and Indicators",
      "rules": [
        "Use consolidators and QC indicators for time series data.",
        "Warm up all indicators or guard with self.is_warming_up.",
        "Avoid loops with history() \u2014 prefetch data outside loops.",
        "Store indicator state per symbol in self.symbol_data dict."
      ],
      "examples": [
        {
          "good": "if self.is_warming_up: return",
          "bad": "for bar in self.history(['SPY'], 100, Resolution.Minute): ..."
        }
      ],
      "tags": [
        "data",
        "indicators",
        "history"
      ]
    },
    {
      "id": "data_structures_and_state",
      "title": "Data Structures and State Management",
      "rules": [
        "Prefer dicts and lists over defaultdict or complex objects.",
        "Store persistent state as attributes (self.).",
        "Avoid globals and external references.",
        "Do not pickle or serialize within QC runtime."
      ],
      "examples": [
        {
          "good": "self.symbol_data = {symbol: {\"roc\": None, \"greeks\": None}}",
          "bad": "global positions; positions = {}"
        }
      ],
      "tags": [
        "data",
        "state",
        "memory"
      ]
    },
    {
      "id": "logging_and_debugging",
      "title": "Logging and Debugging",
      "rules": [
        "Use self.debug() for quick logging, self.log() for standard, self.error() for exceptions.",
        "Throttle debug statements in on_data to prevent spam.",
        "Avoid print() or external logging frameworks."
      ],
      "examples": [
        {
          "good": "self.debug(f'IV ratio: {iv_ratio:.2f}')",
          "bad": "print('IV ratio:', iv_ratio)"
        }
      ],
      "tags": [
        "logging",
        "debug"
      ]
    },
    {
      "id": "execution_and_order_management",
      "title": "Execution and Order Management",
      "rules": [
        "Execute trades only after confirming sufficient portfolio value.",
        "Check self.portfolio.invested before re-entering.",
        "Close and rebuild multi-leg combos; do not modify live legs.",
        "Use on_order_event for fills and order tracking."
      ],
      "examples": [
        {
          "good": "if not self.portfolio.invested: self.add_option_strategy(strategy, 1)",
          "bad": "self.add_option_strategy(strategy, 1)"
        }
      ],
      "tags": [
        "execution",
        "orders",
        "risk"
      ]
    },
    {
      "id": "finalization",
      "title": "Finalization and Runtime Notes",
      "rules": [
        "Do not assume access to file system or OS variables.",
        "Do not use f-string format specifiers beyond Python 3.8 compatibility.",
        "Avoid async/await or parallel execution.",
        "End algorithm scripts cleanly; omit __main__ guards in QC context."
      ],
      "examples": [
        {
          "good": "# runs safely inside QC cloud",
          "bad": "if __name__ == '__main__': QCAlgorithm.main()"
        }
      ],
      "tags": [
        "runtime",
        "compatibility"
      ]
    },
    {
      "id": "research_and_notebooks",
      "title": "QC Research and Jupyter Notebooks",
      "rules": [
        "NEVER include emojis in notebook cells (causes encoding errors in QC Research).",
        "Use official QuantConnect API: api.list_backtests(), api.read_backtest(), NOT qb.ReadProject().",
        "Always validate backtest_id exists before use - fetch from API, never hardcode placeholders.",
        "When generating notebooks programmatically, use actual newline characters (\\n) not escaped strings (\\\\n).",
        "Import QuantConnect.Api for backtest/project operations: from QuantConnect.Api import Api.",
        "Filter for completed backtests only: [b for b in backtests.backtests if b.progress == 1].",
        "Sort by creation date to get latest: sorted(..., key=lambda x: x.created, reverse=True)[0]."
      ],
      "examples": [
        {
          "good": "from QuantConnect.Api import Api\napi = Api()\nbacktests = api.list_backtests(qb.project_id)\ncompleted = [b for b in backtests.backtests if b.progress == 1]\nlatest = sorted(completed, key=lambda x: x.created, reverse=True)[0]\nbacktest_id = latest.backtest_id",
          "bad": "project = qb.ReadProject(project_id)  # WRONG - method doesn't exist\nbacktest_id = 'manual_from_screenshot'  # WRONG - placeholder ID\nprint('Status: âœ… PASS')  # WRONG - emojis not allowed"
        }
      ],
      "tags": [
        "research",
        "notebooks",
        "jupyter",
        "api",
        "validation"
      ]
    }
  ],
  "summary": {
    "core_principles": [
      "Write deterministic, environment-safe Python.",
      "Avoid runtime dependencies unavailable in QC.",
      "Guard every data access and execution path.",
      "Leverage OptionStrategies to prevent structural errors.",
      "Prefer explicit initialization and state management."
    ],
    "quick_checklist": [
      "\u2705 snake_case everywhere",
      "\u2705 valid QC imports",
      "\u2705 initialize() defines dates, cash, assets",
      "\u2705 no file I/O or async",
      "\u2705 on_data guards for empty chains",
      "\u2705 use self.debug() not print()",
      "\u2705 OptionStrategies for combos",
      "\u2705 define self.symbol_data in initialize",
      "\u2705 NO emojis in ANY code uploaded to QC (STRICT - causes encoding issues)",
      "\u2705 use official QC API only (api.list_backtests, NOT qb.ReadProject)",
      "\u2705 never use placeholder backtest_ids (manual_from_screenshot, REPLACE_ME, TODO)",
      "\u2705 validate generated notebooks before upload (check JSON escaping)"
    ]
  }
}