{
  "tool": "qc_backtest",
  "version": "1.1.0",
  "description": "QuantConnect backtest execution for Phase 3 hypothesis testing",
  "sections": [
    {
      "id": "cli_commands",
      "title": "CLI Commands Reference",
      "content": "**Top-Level Commands**\n\nqc_backtest.py provides argparse-based CLI (legacy pattern).\n\n---\n\n## --run - Complete Workflow\n\n```bash\npython qc_backtest.py --run --name \"MyStrategy\" --file strategy.py\n```\n\n**Purpose**: Complete workflow - create project + upload + backtest\n\n**Options**:\n- `--name TEXT`: Project name (required)\n- `--file PATH`: Strategy Python file (required)\n- `--output PATH`: Output JSON file for results\n\n**Example**:\n```bash\npython qc_backtest.py --run --name \"H5_StatArb\" --file strategy.py --output results.json\n```\n\n**What It Does**:\n1. Creates new QC project\n2. Uploads strategy code to main.py\n3. Compiles project\n4. Runs backtest\n5. Waits for completion\n6. Saves results to output file\n\n---\n\n## --create - Create Project Only\n\n```bash\npython qc_backtest.py --create --name \"MyStrategy\"\n```\n\n**Purpose**: Create QC project without running backtest\n\n**Returns**: Project ID\n\n---\n\n## --backtest - Run Backtest on Existing Project\n\n```bash\npython qc_backtest.py --backtest --project-id 12345 --file strategy.py\n```\n\n**Purpose**: Upload code and run backtest on existing project\n\n**Options**:\n- `--project-id INT`: Existing project ID (required)\n- `--file PATH`: Strategy Python file (required)\n\n---\n\n## --status - Check Backtest Status\n\n```bash\npython qc_backtest.py --status --backtest-id abc123\n```\n\n**Purpose**: Check if backtest is running or completed\n\n---\n\n## --results - Download Backtest Results\n\n```bash\npython qc_backtest.py --results --backtest-id abc123 --output results.json\n```\n\n**Purpose**: Download and parse backtest results\n\n**Output**: JSON file with performance metrics\n\n---\n\n## --list - List All Projects\n\n```bash\npython qc_backtest.py --list\n```\n\n**Purpose**: Show all QC projects in account\n\n---\n\n## Complete Workflow Example\n\n```bash\n# Option 1: One-step workflow (recommended)\npython qc_backtest.py --run --name \"H5_StatArb\" --file strategy.py\n\n# Option 2: Step-by-step\npython qc_backtest.py --create --name \"H5_StatArb\"\n# Returns: project_id=12345\n\npython qc_backtest.py --backtest --project-id 12345 --file strategy.py\n# Returns: backtest_id=abc123\n\npython qc_backtest.py --status --backtest-id abc123\n# Returns: status=completed\n\npython qc_backtest.py --results --backtest-id abc123 --output results.json\n```\n\n**NOTE**: qc_backtest.py uses argparse (not click). Future: migrate to click + help_loader pattern.",
      "tags": [
        "cli",
        "commands",
        "reference"
      ],
      "priority": 1,
      "related_sections": [
        "api_methods",
        "workflow_overview"
      ]
    },
    {
      "id": "api_methods",
      "title": "API Methods Reference (qc_api.py)",
      "content": "**Low-Level API Methods for Backtesting**\n\nThese are the `qc_api.py` methods that `qc_backtest.py` calls under the hood.\n\n---\n\n## create_project()\n\n**Purpose**: Create new QuantConnect project\n\n**Signature**:\n```python\napi.create_project(\n    name: str,\n    language: str = \"Py\"\n) -> dict\n```\n\n**Parameters**:\n- `name`: Project name (e.g., \"H5_StatArb\")\n- `language`: Programming language (\"Py\" for Python, \"C#\" for C#)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'projects': [\n        {\n            'projectId': 12345,\n            'name': 'H5_StatArb',\n            'created': '2025-11-13T12:00:00Z'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\nresult = api.create_project(\"H5_StatArb\", \"Py\")\nproject_id = result['projects'][0]['projectId']\nprint(f\"Created project: {project_id}\")\n```\n\n**HTTP Endpoint**: `POST /projects/create`\n\n---\n\n## upload_file()\n\n**Purpose**: Upload or update file in project\n\n**Signature**:\n```python\napi.upload_file(\n    project_id: int,\n    name: str,\n    content: str\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `name`: File name (e.g., \"main.py\")\n- `content`: File content (Python code as string)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'files': [\n        {'name': 'main.py', 'content': '...'}\n    ]\n}\n```\n\n**Example**:\n```python\n# Read strategy file\nwith open('strategy.py') as f:\n    code = f.read()\n\n# Upload to QC project\nresult = api.upload_file(project_id, \"main.py\", code)\nprint(\"Strategy uploaded\")\n```\n\n**HTTP Endpoint**: `POST /files/update` or `POST /files/create`\n\n---\n\n## compile_project()\n\n**Purpose**: Compile project (verify code syntax)\n\n**Signature**:\n```python\napi.compile_project(\n    project_id: int\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n\n**Returns**:\n```python\n{\n    'success': True,\n    'compileId': 'compile-123',\n    'state': 'BuildSuccess'\n}\n```\n\n**Example**:\n```python\nresult = api.compile_project(project_id)\nif result['state'] == 'BuildSuccess':\n    compile_id = result['compileId']\n    print(\"Compilation successful\")\nelse:\n    print(\"Compilation failed:\", result.get('logs'))\n```\n\n**HTTP Endpoint**: `POST /compile/create`\n\n---\n\n## create_backtest()\n\n**Purpose**: Submit backtest job to QuantConnect\n\n**Signature**:\n```python\napi.create_backtest(\n    project_id: int,\n    compile_id: str = None,\n    name: str = None\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `compile_id`: Compile ID (optional, will compile if not provided)\n- `name`: Backtest name (optional, auto-generated if not provided)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'backtests': [\n        {\n            'backtestId': 'abc123def456',\n            'name': 'Backtest_20251113',\n            'status': 'Running'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\nresult = api.create_backtest(project_id, name=\"H5_StatArb_Backtest\")\nbacktest_id = result['backtests'][0]['backtestId']\nprint(f\"Backtest started: {backtest_id}\")\n```\n\n**HTTP Endpoint**: `POST /backtests/create`\n\n---\n\n## wait_for_backtest()\n\n**Purpose**: Poll backtest status until completion or timeout\n\n**Signature**:\n```python\napi.wait_for_backtest(\n    project_id: int,\n    backtest_id: str,\n    timeout: int = 300,\n    poll_interval: int = 5\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `backtest_id`: Backtest ID from `create_backtest()`\n- `timeout`: Maximum wait time in seconds (default: 300 = 5 min)\n- `poll_interval`: Seconds between status checks (default: 5)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'backtest': {\n        'backtestId': 'abc123',\n        'status': 'Completed',\n        'result': { /* full results */ },\n        'statistics': { /* performance metrics */ }\n    }\n}\n```\n\n**Example**:\n```python\n# Wait for backtest to complete\nresult = api.wait_for_backtest(project_id, backtest_id, timeout=600)\n\nif result['success']:\n    print(\"Backtest completed\")\n    stats = result['backtest']['statistics']\n    print(f\"Sharpe: {stats['sharpeRatio']}\")\nelse:\n    print(\"Backtest failed:\", result.get('error'))\n```\n\n**HTTP Endpoint**: `GET /backtests/read` (called repeatedly)\n\n---\n\n## read_backtest()\n\n**Purpose**: Get backtest results (single check, non-blocking)\n\n**Signature**:\n```python\napi.read_backtest(\n    project_id: int,\n    backtest_id: str\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `backtest_id`: Backtest ID\n\n**Returns**:\n```python\n{\n    'success': True,\n    'backtest': {\n        'backtestId': 'abc123',\n        'status': 'Completed',\n        'result': { /* full results */ },\n        'statistics': {\n            'sharpeRatio': 0.85,\n            'drawdown': 0.18,\n            'totalNetProfit': 0.42,\n            /* ... more metrics */\n        }\n    }\n}\n```\n\n**Example**:\n```python\nresult = api.read_backtest(project_id, backtest_id)\nif result['backtest']['status'] == 'Completed':\n    print(\"Backtest finished\")\n```\n\n**HTTP Endpoint**: `GET /backtests/read`\n\n---\n\n## read_files()\n\n**Purpose**: Read files from QC project\n\n**Signature**:\n```python\napi.read_files(\n    project_id: int,\n    filename: str = None\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `filename`: Specific file to read (optional, None = all files)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'files': [\n        {\n            'name': 'main.py',\n            'content': '# Strategy code here...'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\n# Read strategy from project\nfiles = api.read_files(project_id, \"main.py\")\ncode = files['files'][0]['content']\nprint(f\"Strategy: {len(code)} chars\")\n```\n\n**HTTP Endpoint**: `GET /files/read`\n\n---\n\n## list_projects()\n\n**Purpose**: List all projects in account\n\n**Signature**:\n```python\napi.list_projects() -> dict\n```\n\n**Returns**:\n```python\n{\n    'success': True,\n    'projects': [\n        {'projectId': 12345, 'name': 'H5_StatArb', 'modified': '2025-11-13'},\n        {'projectId': 12346, 'name': 'H6_MomentumReversal', 'modified': '2025-11-12'}\n    ]\n}\n```\n\n**Example**:\n```python\nresult = api.list_projects()\nfor project in result['projects']:\n    print(f\"{project['projectId']}: {project['name']}\")\n```\n\n**HTTP Endpoint**: `GET /projects/read`\n\n---\n\n## Complete API Workflow\n\n```python\nfrom qc_api import QuantConnectAPI\nimport json\n\n# Initialize API\napi = QuantConnectAPI()\n\n# Step 1: Create project\nproject = api.create_project(\"H5_StatArb\", \"Py\")\nproject_id = project['projects'][0]['projectId']\nprint(f\"Project ID: {project_id}\")\n\n# Step 2: Upload strategy\nwith open('strategy.py') as f:\n    code = f.read()\napi.upload_file(project_id, \"main.py\", code)\nprint(\"Strategy uploaded\")\n\n# Step 3: Compile\ncompile_result = api.compile_project(project_id)\ncompile_id = compile_result['compileId']\nprint(\"Compilation successful\")\n\n# Step 4: Create backtest\nbacktest = api.create_backtest(project_id, compile_id, \"H5_Backtest\")\nbacktest_id = backtest['backtests'][0]['backtestId']\nprint(f\"Backtest ID: {backtest_id}\")\n\n# Step 5: Wait for completion\nresult = api.wait_for_backtest(project_id, backtest_id, timeout=600)\n\n# Step 6: Extract results\nstats = result['backtest']['statistics']\nprint(f\"Sharpe: {stats['sharpeRatio']:.3f}\")\nprint(f\"Drawdown: {stats['drawdown']:.1%}\")\nprint(f\"Return: {stats['totalNetProfit']:.1%}\")\n\n# Save to file\nwith open('backtest_results.json', 'w') as f:\n    json.dump(result, f, indent=2)\n```",
      "tags": [
        "api",
        "methods",
        "qc_api"
      ],
      "priority": 1,
      "related_sections": [
        "cli_commands",
        "workflow_overview"
      ]
    },
    {
      "id": "qc_coding_standards",
      "title": "QuantConnect Coding Standards",
      "content": "**Essential QC Platform Coding Rules**\n\nWhen writing strategy code for backtesting, follow these QuantConnect platform standards.\n\n**Complete Reference**: See HELP/qc_guide.json for full specification\n\n---\n\n## Syntax and Naming\n\n‚úÖ **CORRECT**:\n```python\n# Variables and functions: snake_case\ndef calculate_signal(prices, period):\n    \"\"\"Calculate trading signal.\"\"\"\n    moving_average = sum(prices[-period:]) / period\n    return signal\n\n# Constants: UPPERCASE\nMINUTE = 60\nDAILY = \"1d\"\nMAX_POSITIONS = 10\n```\n\n‚ùå **WRONG - AVOID PascalCase**:\n```python\ndef CalculateSignal(Prices, Period):  # PascalCase - WRONG (legacy QC)\n    MovingAverage = sum(Prices[-Period:]) / Period  # Mixed case - WRONG\n\nclass MyStrategy:  # PascalCase class - AVOID (use snake_case)\n    pass\n```\n\n**Rules**:\n- **ALWAYS** use `snake_case` for variables, functions, and classes\n- **ONLY** use `UPPERCASE` for constants (MINUTE, DAILY, MAX_POSITIONS, etc.)\n- **NEVER** use `PascalCase` (legacy QuantConnect convention - avoid at all costs)\n- **NEVER** use emojis in code - BANNED on QC platform (causes syntax errors)\n- Follow PEP8 (4 spaces, no tabs)\n- Triple-quoted docstrings\n\n---\n\n## Emojis - BANNED on QC Platform\n\n‚ùå **CRITICAL: NEVER use emojis in QC code**\n\nEmojis cause **syntax errors** and **compilation failures** on QuantConnect platform.\n\n**WRONG - Will cause syntax error**:\n```python\ndef Initialize(self):\n    self.SetStartDate(2019, 1, 1)  # üìÖ Start date - SYNTAX ERROR!\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)  # üìà Add SPY - ERROR!\n    \n    # üöÄ Initialize strategy - SYNTAX ERROR!\n    self.rsi_period = 14\n```\n\n**Error Message**:\n```\nRuntimeError: Syntax error in algorithm. \nInvalid character in identifier at line X\n```\n\n**CORRECT - Use plain text comments**:\n```python\ndef Initialize(self):\n    # Set backtest start date\n    self.SetStartDate(2019, 1, 1)\n    \n    # Add SPY equity\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n    \n    # Initialize strategy parameters\n    self.rsi_period = 14\n```\n\n**Why Emojis Fail**:\n- QC platform uses Python 3.8 with strict ASCII enforcement\n- Emojis are Unicode characters (U+1F600 etc.)\n- Python parser rejects non-ASCII in code (outside strings)\n- Compilation fails before backtest even runs\n\n**Even in strings - AVOID**:\n```python\n# ‚ùå RISKY - May work in strings but avoid anyway\nself.Debug(\"Portfolio value: üí∞ $100,000\")  # Avoid\n\n# ‚úÖ SAFE - Use plain text\nself.Debug(\"Portfolio value: $100,000\")  # Correct\n```\n\n**Rule**: **NO EMOJIS ANYWHERE** in QC code - comments, strings, or identifiers.\n\n---\n\n## Quick Checklist\n\nBefore running backtest, verify:\n\n- ‚úÖ `snake_case` for variables/functions/classes, `UPPERCASE` for constants\n- ‚úÖ Valid QC imports only (no requests, yfinance, etc.)\n- ‚úÖ `Initialize()` defines dates, cash, securities\n- ‚úÖ No file I/O or async\n- ‚úÖ `OnData()` guards with `IsWarmingUp`\n- ‚úÖ Use `self.Debug()` not `print()`\n- ‚úÖ Indicators created in `Initialize()`\n- ‚úÖ **NO EMOJIS** in code (banned - causes syntax errors)\n\n**Full Specification**: HELP/qc_guide.json",
      "tags": [
        "coding_standards",
        "qc_platform",
        "best_practices"
      ],
      "priority": 1,
      "related_sections": []
    }
  ],
  "metadata": {
    "created": "2025-11-13",
    "updated": "2025-11-13",
    "version": "1.1.0",
    "authors": [
      "Claude"
    ],
    "skill": "quantconnect-backtest",
    "changelog": "v1.1.0: Added CLI Commands and API Methods sections. v1.0.0: Initial version with emoji ban rule"
  }
}