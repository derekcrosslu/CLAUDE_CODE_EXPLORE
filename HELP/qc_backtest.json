{
  "tool": "qc_backtest",
  "version": "1.3.0",
  "description": "QuantConnect backtest execution for Phase 3 hypothesis testing",
  "sections": [
    {
      "id": "cli_commands",
      "title": "CLI Commands Reference",
      "content": "**Top-Level Commands**\n\nqc_backtest.py provides argparse-based CLI (legacy pattern).\n\n---\n\n## --run - Complete Workflow\n\n```bash\npython qc_backtest.py --run --name \"MyStrategy\" --file strategy.py\n```\n\n**Purpose**: Complete workflow - create project + upload + backtest\n\n**Options**:\n- `--name TEXT`: Project name (required)\n- `--file PATH`: Strategy Python file (required)\n- `--output PATH`: Output JSON file for results\n\n**Example**:\n```bash\npython qc_backtest.py --run --name \"H5_StatArb\" --file strategy.py --output results.json\n```\n\n**What It Does**:\n1. Creates new QC project\n2. Uploads strategy code to main.py\n3. Compiles project\n4. Runs backtest\n5. Waits for completion\n6. Saves results to output file\n\n---\n\n## --create - Create Project Only\n\n```bash\npython qc_backtest.py --create --name \"MyStrategy\"\n```\n\n**Purpose**: Create QC project without running backtest\n\n**Returns**: Project ID\n\n---\n\n## --backtest - Run Backtest on Existing Project\n\n```bash\npython qc_backtest.py --backtest --project-id 12345 --file strategy.py\n```\n\n**Purpose**: Upload code and run backtest on existing project\n\n**Options**:\n- `--project-id INT`: Existing project ID (required)\n- `--file PATH`: Strategy Python file (required)\n\n---\n\n## --status - Check Backtest Status\n\n```bash\npython qc_backtest.py --status --backtest-id abc123\n```\n\n**Purpose**: Check if backtest is running or completed\n\n---\n\n## --results - Download Backtest Results\n\n```bash\npython qc_backtest.py --results --backtest-id abc123 --output results.json\n```\n\n**Purpose**: Download and parse backtest results\n\n**Output**: JSON file with performance metrics\n\n---\n\n## --list - List All Projects\n\n```bash\npython qc_backtest.py --list\n```\n\n**Purpose**: Show all QC projects in account\n\n---\n\n## Complete Workflow Example\n\n```bash\n# Option 1: One-step workflow (recommended)\npython qc_backtest.py --run --name \"H5_StatArb\" --file strategy.py\n\n# Option 2: Step-by-step\npython qc_backtest.py --create --name \"H5_StatArb\"\n# Returns: project_id=12345\n\npython qc_backtest.py --backtest --project-id 12345 --file strategy.py\n# Returns: backtest_id=abc123\n\npython qc_backtest.py --status --backtest-id abc123\n# Returns: status=completed\n\npython qc_backtest.py --results --backtest-id abc123 --output results.json\n```\n\n**NOTE**: qc_backtest.py uses argparse (not click). Future: migrate to click + help_loader pattern.",
      "tags": [
        "cli",
        "commands",
        "reference"
      ],
      "priority": 1,
      "related_sections": [
        "api_methods",
        "workflow_overview"
      ]
    },
    {
      "id": "api_methods",
      "title": "API Methods Reference (qc_api.py)",
      "content": "**Low-Level API Methods for Backtesting**\n\nThese are the `qc_api.py` methods that `qc_backtest.py` calls under the hood.\n\n---\n\n## create_project()\n\n**Purpose**: Create new QuantConnect project\n\n**Signature**:\n```python\napi.create_project(\n    name: str,\n    language: str = \"Py\"\n) -> dict\n```\n\n**Parameters**:\n- `name`: Project name (e.g., \"H5_StatArb\")\n- `language`: Programming language (\"Py\" for Python, \"C#\" for C#)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'projects': [\n        {\n            'projectId': 12345,\n            'name': 'H5_StatArb',\n            'created': '2025-11-13T12:00:00Z'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\nresult = api.create_project(\"H5_StatArb\", \"Py\")\nproject_id = result['projects'][0]['projectId']\nprint(f\"Created project: {project_id}\")\n```\n\n**HTTP Endpoint**: `POST /projects/create`\n\n---\n\n## upload_file()\n\n**Purpose**: Upload or update file in project\n\n**Signature**:\n```python\napi.upload_file(\n    project_id: int,\n    name: str,\n    content: str\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `name`: File name (e.g., \"main.py\")\n- `content`: File content (Python code as string)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'files': [\n        {'name': 'main.py', 'content': '...'}\n    ]\n}\n```\n\n**Example**:\n```python\n# Read strategy file\nwith open('strategy.py') as f:\n    code = f.read()\n\n# Upload to QC project\nresult = api.upload_file(project_id, \"main.py\", code)\nprint(\"Strategy uploaded\")\n```\n\n**HTTP Endpoint**: `POST /files/update` or `POST /files/create`\n\n---\n\n## compile_project()\n\n**Purpose**: Compile project (verify code syntax)\n\n**Signature**:\n```python\napi.compile_project(\n    project_id: int\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n\n**Returns**:\n```python\n{\n    'success': True,\n    'compileId': 'compile-123',\n    'state': 'BuildSuccess'\n}\n```\n\n**Example**:\n```python\nresult = api.compile_project(project_id)\nif result['state'] == 'BuildSuccess':\n    compile_id = result['compileId']\n    print(\"Compilation successful\")\nelse:\n    print(\"Compilation failed:\", result.get('logs'))\n```\n\n**HTTP Endpoint**: `POST /compile/create`\n\n---\n\n## create_backtest()\n\n**Purpose**: Submit backtest job to QuantConnect\n\n**Signature**:\n```python\napi.create_backtest(\n    project_id: int,\n    compile_id: str = None,\n    name: str = None\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `compile_id`: Compile ID (optional, will compile if not provided)\n- `name`: Backtest name (optional, auto-generated if not provided)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'backtests': [\n        {\n            'backtestId': 'abc123def456',\n            'name': 'Backtest_20251113',\n            'status': 'Running'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\nresult = api.create_backtest(project_id, name=\"H5_StatArb_Backtest\")\nbacktest_id = result['backtests'][0]['backtestId']\nprint(f\"Backtest started: {backtest_id}\")\n```\n\n**HTTP Endpoint**: `POST /backtests/create`\n\n---\n\n## wait_for_backtest()\n\n**Purpose**: Poll backtest status until completion or timeout\n\n**Signature**:\n```python\napi.wait_for_backtest(\n    project_id: int,\n    backtest_id: str,\n    timeout: int = 300,\n    poll_interval: int = 5\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `backtest_id`: Backtest ID from `create_backtest()`\n- `timeout`: Maximum wait time in seconds (default: 300 = 5 min)\n- `poll_interval`: Seconds between status checks (default: 5)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'backtest': {\n        'backtestId': 'abc123',\n        'status': 'Completed',\n        'result': { /* full results */ },\n        'statistics': { /* performance metrics */ }\n    }\n}\n```\n\n**Example**:\n```python\n# Wait for backtest to complete\nresult = api.wait_for_backtest(project_id, backtest_id, timeout=600)\n\nif result['success']:\n    print(\"Backtest completed\")\n    stats = result['backtest']['statistics']\n    print(f\"Sharpe: {stats['sharpeRatio']}\")\nelse:\n    print(\"Backtest failed:\", result.get('error'))\n```\n\n**HTTP Endpoint**: `GET /backtests/read` (called repeatedly)\n\n---\n\n## read_backtest()\n\n**Purpose**: Get backtest results (single check, non-blocking)\n\n**Signature**:\n```python\napi.read_backtest(\n    project_id: int,\n    backtest_id: str\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `backtest_id`: Backtest ID\n\n**Returns**:\n```python\n{\n    'success': True,\n    'backtest': {\n        'backtestId': 'abc123',\n        'status': 'Completed',\n        'result': { /* full results */ },\n        'statistics': {\n            'sharpeRatio': 0.85,\n            'drawdown': 0.18,\n            'totalNetProfit': 0.42,\n            /* ... more metrics */\n        }\n    }\n}\n```\n\n**Example**:\n```python\nresult = api.read_backtest(project_id, backtest_id)\nif result['backtest']['status'] == 'Completed':\n    print(\"Backtest finished\")\n```\n\n**HTTP Endpoint**: `GET /backtests/read`\n\n---\n\n## read_files()\n\n**Purpose**: Read files from QC project\n\n**Signature**:\n```python\napi.read_files(\n    project_id: int,\n    filename: str = None\n) -> dict\n```\n\n**Parameters**:\n- `project_id`: QC project ID\n- `filename`: Specific file to read (optional, None = all files)\n\n**Returns**:\n```python\n{\n    'success': True,\n    'files': [\n        {\n            'name': 'main.py',\n            'content': '# Strategy code here...'\n        }\n    ]\n}\n```\n\n**Example**:\n```python\n# Read strategy from project\nfiles = api.read_files(project_id, \"main.py\")\ncode = files['files'][0]['content']\nprint(f\"Strategy: {len(code)} chars\")\n```\n\n**HTTP Endpoint**: `GET /files/read`\n\n---\n\n## list_projects()\n\n**Purpose**: List all projects in account\n\n**Signature**:\n```python\napi.list_projects() -> dict\n```\n\n**Returns**:\n```python\n{\n    'success': True,\n    'projects': [\n        {'projectId': 12345, 'name': 'H5_StatArb', 'modified': '2025-11-13'},\n        {'projectId': 12346, 'name': 'H6_MomentumReversal', 'modified': '2025-11-12'}\n    ]\n}\n```\n\n**Example**:\n```python\nresult = api.list_projects()\nfor project in result['projects']:\n    print(f\"{project['projectId']}: {project['name']}\")\n```\n\n**HTTP Endpoint**: `GET /projects/read`\n\n---\n\n## Complete API Workflow\n\n```python\nfrom qc_api import QuantConnectAPI\nimport json\n\n# Initialize API\napi = QuantConnectAPI()\n\n# Step 1: Create project\nproject = api.create_project(\"H5_StatArb\", \"Py\")\nproject_id = project['projects'][0]['projectId']\nprint(f\"Project ID: {project_id}\")\n\n# Step 2: Upload strategy\nwith open('strategy.py') as f:\n    code = f.read()\napi.upload_file(project_id, \"main.py\", code)\nprint(\"Strategy uploaded\")\n\n# Step 3: Compile\ncompile_result = api.compile_project(project_id)\ncompile_id = compile_result['compileId']\nprint(\"Compilation successful\")\n\n# Step 4: Create backtest\nbacktest = api.create_backtest(project_id, compile_id, \"H5_Backtest\")\nbacktest_id = backtest['backtests'][0]['backtestId']\nprint(f\"Backtest ID: {backtest_id}\")\n\n# Step 5: Wait for completion\nresult = api.wait_for_backtest(project_id, backtest_id, timeout=600)\n\n# Step 6: Extract results\nstats = result['backtest']['statistics']\nprint(f\"Sharpe: {stats['sharpeRatio']:.3f}\")\nprint(f\"Drawdown: {stats['drawdown']:.1%}\")\nprint(f\"Return: {stats['totalNetProfit']:.1%}\")\n\n# Save to file\nwith open('backtest_results.json', 'w') as f:\n    json.dump(result, f, indent=2)\n```",
      "tags": [
        "api",
        "methods",
        "qc_api"
      ],
      "priority": 1,
      "related_sections": [
        "cli_commands",
        "workflow_overview"
      ]
    },
    {
      "id": "reading_results",
      "title": "Reading Backtest Results, Metrics, and Logs",
      "content": "**How to Access Backtest Data**\n\nAfter a backtest completes, you can read results, performance metrics, trade statistics, and error logs.\n\n---\n\n## Method 1: Using parse_backtest_results() (Recommended)\n\n**Purpose**: Get structured, parsed metrics ready for decision-making\n\n**Function**:\n```python\nfrom qc_api import parse_backtest_results\n\n# After backtest completes\nresult = api.wait_for_backtest(project_id, backtest_id)\n\n# Parse into structured format\nmetrics = parse_backtest_results(result)\n```\n\n**Returned Structure**:\n```python\n{\n    \"success\": True,\n    \"backtest_id\": \"abc123\",\n    \"project_id\": 12345,\n    \"name\": \"H5_StatArb_Backtest\",\n    \"status\": \"Completed\",\n    \"completed\": \"2025-11-13T12:00:00Z\",\n    \"created\": \"2025-11-13T11:30:00Z\",\n    \n    # Performance metrics (float values, ready to use)\n    \"performance\": {\n        \"sharpe_ratio\": 0.85,\n        \"sortino_ratio\": 1.02,\n        \"max_drawdown\": 0.18,      # 18% drawdown\n        \"total_return\": 0.42,       # 42% return\n        \"annual_return\": 0.15,      # 15% annualized\n        \"win_rate\": 0.47,           # 47% win rate\n        \"loss_rate\": 0.53,          # 53% loss rate\n        \"psr\": 0.89                 # Probabilistic Sharpe Ratio\n    },\n    \n    # Trading statistics\n    \"trading\": {\n        \"total_orders\": 245,\n        \"total_trades\": 120,\n        \"winning_trades\": 56,\n        \"losing_trades\": 64,\n        \"average_win\": 0.025,       # 2.5% avg win\n        \"average_loss\": -0.018,     # -1.8% avg loss\n        \"profit_loss_ratio\": 1.39,\n        \"largest_win\": 0.085,       # 8.5% largest win\n        \"largest_loss\": -0.042      # -4.2% largest loss\n    },\n    \n    # Risk metrics\n    \"risk\": {\n        \"alpha\": 0.05,\n        \"beta\": 0.92,\n        \"volatility\": 0.12          # 12% annual volatility\n    },\n    \n    # Raw data (for custom analysis)\n    \"raw_statistics\": { /* full QC statistics */ },\n    \"raw_portfolio_stats\": { /* full portfolio data */ },\n    \"raw_trade_stats\": { /* full trade data */ }\n}\n```\n\n**Example Usage**:\n```python\nfrom qc_api import QuantConnectAPI, parse_backtest_results\n\napi = QuantConnectAPI()\n\n# Run backtest\nbacktest = api.create_backtest(project_id, name=\"H5_Backtest\")\nbacktest_id = backtest['backtests'][0]['backtestId']\n\n# Wait for completion\nresult = api.wait_for_backtest(project_id, backtest_id)\n\n# Parse results\nmetrics = parse_backtest_results(result)\n\n# Access metrics\nprint(f\"Sharpe Ratio: {metrics['performance']['sharpe_ratio']:.2f}\")\nprint(f\"Max Drawdown: {metrics['performance']['max_drawdown']:.1%}\")\nprint(f\"Total Trades: {metrics['trading']['total_trades']}\")\nprint(f\"Win Rate: {metrics['trading']['winning_trades'] / metrics['trading']['total_trades']:.1%}\")\n\n# Check for errors\nif metrics.get('error'):\n    print(f\"Backtest Error: {metrics['error']}\")\n    if metrics.get('stacktrace'):\n        print(f\"Stacktrace:\\n{metrics['stacktrace']}\")\n```\n\n---\n\n## Method 2: Direct API Call (Raw Data)\n\n**Purpose**: Get raw, unprocessed backtest data from QC\n\n**Function**:\n```python\nresult = api.read_backtest(project_id, backtest_id)\n```\n\n**Returned Structure** (Raw QC API Response):\n```python\n{\n    'success': True,\n    'backtest': {\n        'backtestId': 'abc123',\n        'projectId': 12345,\n        'status': 'Completed',\n        'name': 'H5_Backtest',\n        'created': '2025-11-13T11:30:00Z',\n        'completed': '2025-11-13T12:00:00Z',\n        \n        # Statistics (formatted strings - harder to parse)\n        'statistics': {\n            'Total Orders': '245',\n            'Average Win': '2.50%',\n            'Average Loss': '-1.80%',\n            'Sharpe Ratio': '0.85',\n            # ... more formatted strings\n        },\n        \n        # TotalPerformance (numeric values - easier to use)\n        'totalPerformance': {\n            'portfolioStatistics': {\n                'sharpeRatio': 0.85,\n                'sortinoRatio': 1.02,\n                'drawdown': 0.18,\n                'totalNetProfit': 0.42,\n                'compoundingAnnualReturn': 0.15,\n                'winRate': 0.47,\n                'lossRate': 0.53,\n                'probabilisticSharpeRatio': 0.89,\n                'alpha': 0.05,\n                'beta': 0.92,\n                'annualStandardDeviation': 0.12\n            },\n            'tradeStatistics': {\n                'totalNumberOfTrades': 120,\n                'numberOfWinningTrades': 56,\n                'numberOfLosingTrades': 64,\n                'averageProfit': 0.025,\n                'averageLoss': -0.018,\n                'profitLossRatio': 1.39,\n                'largestProfit': 0.085,\n                'largestLoss': -0.042\n            }\n        },\n        \n        # Charts (equity curve, drawdown, etc.)\n        'charts': {\n            'Strategy Equity': { /* equity curve data */ },\n            'Drawdown': { /* drawdown data */ },\n            'Benchmark': { /* benchmark comparison */ }\n        },\n        \n        # Orders (all executed orders)\n        'orders': [\n            {\n                'time': '2023-01-05T10:30:00Z',\n                'symbol': 'SPY',\n                'type': 'Market',\n                'direction': 'Buy',\n                'quantity': 100,\n                'price': 385.50,\n                'status': 'Filled'\n            },\n            # ... more orders\n        ],\n        \n        # Runtime logs (Debug, Log, Error calls)\n        'logs': [\n            '2023-01-05 10:00:00 : Algorithm initialized',\n            '2023-01-05 10:30:00 : Signal detected: RSI = 28.5',\n            '2023-01-05 10:30:01 : Order placed: SPY 100 @ Market',\n            # ... more logs\n        ],\n        \n        # Errors (if any)\n        'error': None,  # or error message if failed\n        'stacktrace': None  # or stacktrace if error occurred\n    }\n}\n```\n\n**Example - Accessing Raw Data**:\n```python\nresult = api.read_backtest(project_id, backtest_id)\n\nif result['success']:\n    backtest = result['backtest']\n    \n    # Access statistics\n    stats = backtest['totalPerformance']['portfolioStatistics']\n    sharpe = stats['sharpeRatio']\n    drawdown = stats['drawdown']\n    \n    # Access trades\n    trade_stats = backtest['totalPerformance']['tradeStatistics']\n    total_trades = trade_stats['totalNumberOfTrades']\n    \n    # Access orders\n    orders = backtest.get('orders', [])\n    print(f\"Total orders executed: {len(orders)}\")\n    \n    # Access logs\n    logs = backtest.get('logs', [])\n    print(\"Last 10 log entries:\")\n    for log in logs[-10:]:\n        print(f\"  {log}\")\n    \n    # Check for errors\n    if backtest.get('error'):\n        print(f\"ERROR: {backtest['error']}\")\n        print(f\"Stacktrace:\\n{backtest.get('stacktrace', 'N/A')}\")\n```\n\n---\n\n## Method 3: Using CLI (Save to File)\n\n**Purpose**: Download results to JSON file for later analysis\n\n**Command**:\n```bash\npython qc_backtest.py --results --backtest-id abc123 --output results.json\n```\n\n**Output File** (results.json):\n```json\n{\n  \"backtest_id\": \"abc123\",\n  \"sharpe_ratio\": 0.85,\n  \"max_drawdown\": 0.18,\n  \"total_return\": 0.42,\n  \"total_trades\": 120,\n  \"win_rate\": 0.47,\n  \"created\": \"2025-11-13T11:30:00Z\",\n  \"completed\": \"2025-11-13T12:00:00Z\"\n}\n```\n\n**Example - Load and Analyze**:\n```python\nimport json\n\n# Load results from file\nwith open('results.json') as f:\n    results = json.load(f)\n\n# Analyze\nprint(f\"Sharpe: {results['sharpe_ratio']:.2f}\")\nprint(f\"Drawdown: {results['max_drawdown']:.1%}\")\n```\n\n---\n\n## Reading Logs\n\n**Purpose**: Debug strategy behavior, see Debug() and Log() output\n\n**How Logs Are Created** (in strategy code):\n```python\nclass MyStrategy(QCAlgorithm):\n    def Initialize(self):\n        self.Debug(\"Strategy initialized\")  # Appears in logs\n        \n    def OnData(self, data):\n        if self.rsi.Current.Value < 30:\n            self.Log(f\"RSI oversold: {self.rsi.Current.Value:.2f}\")  # Appears in logs\n            self.SetHoldings(\"SPY\", 1.0)\n```\n\n**Accessing Logs**:\n```python\nresult = api.read_backtest(project_id, backtest_id)\nlogs = result['backtest'].get('logs', [])\n\n# Print all logs\nfor log_entry in logs:\n    print(log_entry)\n\n# Filter specific logs\ndebug_logs = [log for log in logs if 'RSI oversold' in log]\nfor log in debug_logs:\n    print(log)\n```\n\n**Log Format**:\n```\nYYYY-MM-DD HH:MM:SS : Message text\n2023-01-05 10:00:00 : Algorithm initialized\n2023-01-05 10:30:00 : RSI oversold: 28.50\n```\n\n---\n\n## Reading Error Messages and Stacktraces\n\n**When Backtest Fails**:\n```python\nresult = api.wait_for_backtest(project_id, backtest_id)\n\nif not result['success']:\n    print(f\"Backtest failed: {result.get('error')}\")\nelif result['backtest'].get('error'):\n    error = result['backtest']['error']\n    stacktrace = result['backtest'].get('stacktrace', 'N/A')\n    \n    print(f\"Runtime Error: {error}\")\n    print(f\"\\nStacktrace:\\n{stacktrace}\")\n    \n    # Common errors:\n    # - \"NameError: name 'xyz' is not defined\"\n    # - \"KeyError: 'SPY'\" (security not added)\n    # - \"AttributeError: 'NoneType' object has no attribute...\"\n    # - Emoji syntax errors (if emojis used in code)\n```\n\n**Emoji Syntax Error Example**:\n```\nRuntimeError: Syntax error in algorithm.\nInvalid character in identifier at line 25\n\nStacktrace:\n  File \"main.py\", line 25\n    self.SetStartDate(2019, 1, 1)  # üìÖ Start date\n                                     ^\nSyntaxError: invalid character in identifier\n```\n\n---\n\n## Common Metrics Explained\n\n**Sharpe Ratio** (`sharpe_ratio`):\n- Risk-adjusted return (higher = better)\n- > 1.0 = good, > 2.0 = excellent\n- Accounts for volatility\n\n**Max Drawdown** (`max_drawdown`):\n- Largest peak-to-trough decline (lower = better)\n- 0.18 = 18% max drawdown\n- Measures worst-case loss\n\n**Total Return** (`total_return`):\n- Overall return over backtest period\n- 0.42 = 42% total return\n\n**Win Rate** (`win_rate`):\n- Percentage of profitable trades\n- 0.47 = 47% of trades were winners\n- > 0.50 = more winners than losers\n\n**Profit/Loss Ratio** (`profit_loss_ratio`):\n- Average win / Average loss\n- 1.39 = avg win is 1.39x avg loss\n- > 1.0 needed if win_rate < 0.50\n\n**Alpha** (`alpha`):\n- Excess return vs benchmark\n- 0.05 = 5% outperformance\n\n**Beta** (`beta`):\n- Correlation to benchmark\n- 0.92 = moves 92% as much as benchmark\n- 1.0 = matches benchmark volatility\n\n**PSR** (`probabilistic_sharpe_ratio`):\n- Confidence that Sharpe > 0\n- 0.89 = 89% confidence Sharpe is positive\n- > 0.95 = very high confidence\n\n---\n\n## Complete Example: Full Results Analysis\n\n```python\nfrom qc_api import QuantConnectAPI, parse_backtest_results\nimport json\n\napi = QuantConnectAPI()\n\n# Run backtest\nbacktest = api.create_backtest(project_id, name=\"H5_Backtest\")\nbacktest_id = backtest['backtests'][0]['backtestId']\n\n# Wait for completion\nresult = api.wait_for_backtest(project_id, backtest_id, timeout=600)\n\n# Parse results\nmetrics = parse_backtest_results(result)\n\n# Check for errors first\nif metrics.get('error'):\n    print(f\"BACKTEST FAILED: {metrics['error']}\")\n    if metrics.get('stacktrace'):\n        print(f\"\\nStacktrace:\\n{metrics['stacktrace']}\")\n    exit(1)\n\n# Print summary\nprint(\"=\" * 60)\nprint(f\"BACKTEST RESULTS: {metrics['name']}\")\nprint(\"=\" * 60)\nprint(f\"\\nBacktest ID: {metrics['backtest_id']}\")\nprint(f\"Status: {metrics['status']}\")\nprint(f\"Completed: {metrics['completed']}\")\n\nprint(f\"\\n--- PERFORMANCE ---\")\nprint(f\"Sharpe Ratio: {metrics['performance']['sharpe_ratio']:.2f}\")\nprint(f\"Sortino Ratio: {metrics['performance']['sortino_ratio']:.2f}\")\nprint(f\"Max Drawdown: {metrics['performance']['max_drawdown']:.1%}\")\nprint(f\"Total Return: {metrics['performance']['total_return']:.1%}\")\nprint(f\"Annual Return: {metrics['performance']['annual_return']:.1%}\")\nprint(f\"PSR: {metrics['performance']['psr']:.2f}\")\n\nprint(f\"\\n--- TRADING ---\")\nprint(f\"Total Trades: {metrics['trading']['total_trades']}\")\nprint(f\"Winning Trades: {metrics['trading']['winning_trades']}\")\nprint(f\"Losing Trades: {metrics['trading']['losing_trades']}\")\nprint(f\"Win Rate: {metrics['trading']['winning_trades'] / metrics['trading']['total_trades']:.1%}\")\nprint(f\"Avg Win: {metrics['trading']['average_win']:.2%}\")\nprint(f\"Avg Loss: {metrics['trading']['average_loss']:.2%}\")\nprint(f\"P/L Ratio: {metrics['trading']['profit_loss_ratio']:.2f}\")\n\nprint(f\"\\n--- RISK ---\")\nprint(f\"Alpha: {metrics['risk']['alpha']:.2%}\")\nprint(f\"Beta: {metrics['risk']['beta']:.2f}\")\nprint(f\"Volatility: {metrics['risk']['volatility']:.1%}\")\n\n# Save to file\nwith open('backtest_results.json', 'w') as f:\n    json.dump(metrics, f, indent=2)\n\nprint(f\"\\n‚úÖ Results saved to backtest_results.json\")\n\n# Access raw logs if needed\nraw_result = api.read_backtest(project_id, backtest_id)\nlogs = raw_result['backtest'].get('logs', [])\nprint(f\"\\nTotal log entries: {len(logs)}\")\nprint(\"Last 5 logs:\")\nfor log in logs[-5:]:\n    print(f\"  {log}\")\n```",
      "tags": [
        "results",
        "metrics",
        "logs",
        "parsing"
      ],
      "priority": 1,
      "related_sections": [
        "api_methods",
        "cli_commands"
      ]
    },
    {
      "id": "qc_coding_standards",
      "title": "QuantConnect Coding Standards",
      "content": "**Essential QC Platform Coding Rules**\n\nWhen writing strategy code for backtesting, follow these QuantConnect platform standards.\n\n**Complete Reference**: See HELP/qc_guide.json for full specification\n\n---\n\n## Syntax and Naming\n\n‚úÖ **CORRECT**:\n```python\n# Variables and functions: snake_case\ndef calculate_signal(prices, period):\n    \"\"\"Calculate trading signal.\"\"\"\n    moving_average = sum(prices[-period:]) / period\n    return signal\n\n# Constants: UPPERCASE\nMINUTE = 60\nDAILY = \"1d\"\nMAX_POSITIONS = 10\n```\n\n‚ùå **WRONG - AVOID PascalCase**:\n```python\ndef CalculateSignal(Prices, Period):  # PascalCase - WRONG (legacy QC)\n    MovingAverage = sum(Prices[-Period:]) / Period  # Mixed case - WRONG\n\nclass MyStrategy:  # PascalCase class - AVOID (use snake_case)\n    pass\n```\n\n**Rules**:\n- **ALWAYS** use `snake_case` for variables, functions, and classes\n- **ONLY** use `UPPERCASE` for constants (MINUTE, DAILY, MAX_POSITIONS, etc.)\n- **NEVER** use `PascalCase` (legacy QuantConnect convention - avoid at all costs)\n- **NEVER** use emojis in code - BANNED on QC platform (causes syntax errors)\n- Follow PEP8 (4 spaces, no tabs)\n- Triple-quoted docstrings\n\n---\n\n## Emojis - BANNED on QC Platform\n\n‚ùå **CRITICAL: NEVER use emojis in QC code**\n\nEmojis cause **syntax errors** and **compilation failures** on QuantConnect platform.\n\n**WRONG - Will cause syntax error**:\n```python\ndef Initialize(self):\n    self.SetStartDate(2019, 1, 1)  # üìÖ Start date - SYNTAX ERROR!\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)  # üìà Add SPY - ERROR!\n    \n    # üöÄ Initialize strategy - SYNTAX ERROR!\n    self.rsi_period = 14\n```\n\n**Error Message**:\n```\nRuntimeError: Syntax error in algorithm. \nInvalid character in identifier at line X\n```\n\n**CORRECT - Use plain text comments**:\n```python\ndef Initialize(self):\n    # Set backtest start date\n    self.SetStartDate(2019, 1, 1)\n    \n    # Add SPY equity\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n    \n    # Initialize strategy parameters\n    self.rsi_period = 14\n```\n\n**Why Emojis Fail**:\n- QC platform uses Python 3.8 with strict ASCII enforcement\n- Emojis are Unicode characters (U+1F600 etc.)\n- Python parser rejects non-ASCII in code (outside strings)\n- Compilation fails before backtest even runs\n\n**Even in strings - AVOID**:\n```python\n# ‚ùå RISKY - May work in strings but avoid anyway\nself.Debug(\"Portfolio value: üí∞ $100,000\")  # Avoid\n\n# ‚úÖ SAFE - Use plain text\nself.Debug(\"Portfolio value: $100,000\")  # Correct\n```\n\n**Rule**: **NO EMOJIS ANYWHERE** in QC code - comments, strings, or identifiers.\n\n---\n\n## Quick Checklist\n\nBefore running backtest, verify:\n\n- ‚úÖ `snake_case` for variables/functions/classes, `UPPERCASE` for constants\n- ‚úÖ Valid QC imports only (no requests, yfinance, etc.)\n- ‚úÖ `Initialize()` defines dates, cash, securities\n- ‚úÖ No file I/O or async\n- ‚úÖ `OnData()` guards with `IsWarmingUp`\n- ‚úÖ Use `self.Debug()` not `print()`\n- ‚úÖ Indicators created in `Initialize()`\n- ‚úÖ **NO EMOJIS** in code (banned - causes syntax errors)\n\n**Full Specification**: HELP/qc_guide.json",
      "tags": [
        "coding_standards",
        "qc_platform",
        "best_practices"
      ],
      "priority": 1,
      "related_sections": []
    },
    {
      "id": "common_errors",
      "title": "Common Errors and Troubleshooting",
      "content": "**Common Backtest Errors and How to Fix Them**\n\n---\n\n## Error: \"RuntimeError: Syntax error in algorithm\"\n\n**Cause**: Code has syntax errors (often emojis or invalid Python)\n\n**Error Message**:\n```\nRuntimeError: Syntax error in algorithm.\nInvalid character in identifier at line 25\n```\n\n**Common Causes**:\n1. **Emojis in code** (MOST COMMON):\n```python\n# ‚ùå WRONG - Causes syntax error\nself.SetStartDate(2019, 1, 1)  # üìÖ Start date - ERROR!\n```\n\n2. **Invalid characters**:\n```python\n# ‚ùå WRONG - Smart quotes instead of regular quotes\nself.Debug(\"Hello\")  # Uses \" instead of \"\n```\n\n3. **Indentation errors** (tabs vs spaces):\n```python\n# ‚ùå WRONG - Mixed tabs and spaces\ndef Initialize(self):\n    self.SetCash(100000)  # 4 spaces\n\tself.spy = self.AddEquity(\"SPY\")  # Tab character - ERROR!\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - No emojis, regular quotes, consistent spaces\ndef Initialize(self):\n    # Set backtest start date\n    self.SetStartDate(2019, 1, 1)\n    self.SetCash(100000)\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n```\n\n---\n\n## Error: \"NameError: name 'SPY' is not defined\"\n\n**Cause**: Using variable before defining it\n\n**Example**:\n```python\n# ‚ùå WRONG - Using self.spy before adding it\ndef Initialize(self):\n    self.SetStartDate(2019, 1, 1)\n\ndef OnData(self, data):\n    price = self.Securities[self.spy].Price  # ERROR: self.spy not defined!\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Add security in Initialize()\ndef Initialize(self):\n    self.SetStartDate(2019, 1, 1)\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)  # Define first\n    \ndef OnData(self, data):\n    price = self.Securities[self.spy].Price  # Now works\n```\n\n---\n\n## Error: \"KeyError: 'SPY'\"\n\n**Cause**: Trying to access security that wasn't added\n\n**Example**:\n```python\n# ‚ùå WRONG - Never added SPY to algorithm\ndef OnData(self, data):\n    if data.ContainsKey(\"SPY\"):  # Returns False\n        price = data[\"SPY\"].Close  # Never reaches here\n    \n    # Later...\n    self.SetHoldings(\"SPY\", 1.0)  # ERROR: SPY not added!\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Add security in Initialize()\ndef Initialize(self):\n    self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n\ndef OnData(self, data):\n    if data.ContainsKey(self.spy.Symbol):\n        self.SetHoldings(self.spy.Symbol, 1.0)  # Now works\n```\n\n---\n\n## Error: \"AttributeError: 'NoneType' object has no attribute...\"\n\n**Cause**: Accessing indicator before it's ready\n\n**Example**:\n```python\n# ‚ùå WRONG - Using indicator without checking IsReady\ndef Initialize(self):\n    self.rsi = self.RSI(\"SPY\", 14)\n\ndef OnData(self, data):\n    if self.rsi.Current.Value < 30:  # ERROR if not ready!\n        self.SetHoldings(\"SPY\", 1.0)\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Check IsReady and IsWarmingUp\ndef Initialize(self):\n    self.SetWarmup(14)  # Warm up indicators\n    self.rsi = self.RSI(\"SPY\", 14)\n\ndef OnData(self, data):\n    if self.IsWarmingUp:\n        return  # Skip during warmup\n    \n    if self.rsi.IsReady and self.rsi.Current.Value < 30:\n        self.SetHoldings(\"SPY\", 1.0)  # Now safe\n```\n\n---\n\n## Error: \"Backtest timed out after 600s\"\n\n**Cause**: Backtest taking too long to complete\n\n**Common Reasons**:\n1. Too many years of data (> 10 years)\n2. Minute/Second resolution with large universe\n3. Complex calculations in OnData()\n4. Large option chains\n\n**Fix**:\n```python\n# Option 1: Reduce time period\nself.SetStartDate(2022, 1, 1)  # 2 years instead of 10\nself.SetEndDate(2023, 12, 31)\n\n# Option 2: Increase timeout when waiting\nresult = api.wait_for_backtest(project_id, backtest_id, timeout=1800)  # 30 min\n\n# Option 3: Use coarser resolution\nself.AddEquity(\"SPY\", Resolution.Daily)  # Daily instead of Minute\n\n# Option 4: Optimize OnData() - avoid heavy calculations\ndef OnData(self, data):\n    # ‚ùå WRONG - Expensive operation every bar\n    for symbol in self.Securities.Keys:\n        history = self.History([symbol], 100, Resolution.Minute)  # Slow!\n    \n    # ‚úÖ CORRECT - Pre-calculate or use indicators\n    if self.rsi.Current.Value < 30:  # Fast\n        self.SetHoldings(\"SPY\", 1.0)\n```\n\n---\n\n## Error: \"Insufficient funds\"\n\n**Cause**: Trying to buy more than portfolio allows\n\n**Example**:\n```python\n# ‚ùå WRONG - Trying to buy too much\ndef OnData(self, data):\n    self.SetHoldings(\"SPY\", 1.5)  # 150% of portfolio - ERROR!\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Stay within limits\ndef OnData(self, data):\n    self.SetHoldings(\"SPY\", 1.0)  # 100% of portfolio\n    \n    # Or check available cash\n    available = self.Portfolio.Cash\n    price = self.Securities[\"SPY\"].Price\n    quantity = int(available / price)\n    \n    if quantity > 0:\n        self.MarketOrder(\"SPY\", quantity)\n```\n\n---\n\n## Error: \"No data for symbol\"\n\n**Cause**: Symbol doesn't have data in backtest period\n\n**Example**:\n```python\n# ‚ùå WRONG - IPO after backtest start\ndef Initialize(self):\n    self.SetStartDate(2000, 1, 1)  # Year 2000\n    self.coin = self.AddCrypto(\"BTCUSD\")  # Bitcoin didn't exist yet!\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Use appropriate date range\ndef Initialize(self):\n    self.SetStartDate(2015, 1, 1)  # Bitcoin has data from ~2011+\n    self.coin = self.AddCrypto(\"BTCUSD\")\n    \n    # Or check if data exists\n    if self.coin.HasData:\n        self.SetHoldings(self.coin.Symbol, 0.1)\n```\n\n---\n\n## Error: \"Cannot access 'self.Portfolio' before initialization\"\n\n**Cause**: Trying to use algorithm attributes in Initialize()\n\n**Example**:\n```python\n# ‚ùå WRONG - Accessing Portfolio too early\ndef Initialize(self):\n    self.SetCash(100000)\n    current_cash = self.Portfolio.Cash  # ERROR: Not initialized yet!\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Access in OnData() or after Initialize()\ndef Initialize(self):\n    self.SetCash(100000)\n    # Don't access Portfolio here\n\ndef OnData(self, data):\n    current_cash = self.Portfolio.Cash  # Now safe\n```\n\n---\n\n## Error: \"Module 'requests' not found\"\n\n**Cause**: Trying to import library not available in QC\n\n**Example**:\n```python\n# ‚ùå WRONG - requests not available\nimport requests  # ERROR!\n\ndef OnData(self, data):\n    response = requests.get(\"https://api.example.com\")\n```\n\n**Fix**:\n```python\n# ‚úÖ CORRECT - Use only QC-approved imports\nfrom AlgorithmImports import *\n\n# Available: pandas, numpy, scipy, sklearn, matplotlib\nimport pandas as pd\nimport numpy as np\n\n# NOT available: requests, yfinance, ta, plotly, etc.\n```\n\n**See**: HELP/qc_guide.json for complete list of allowed imports\n\n---\n\n## Error: \"Compilation failed\"\n\n**Cause**: Code doesn't compile (syntax or import errors)\n\n**How to Debug**:\n```python\n# Check compilation result\ncompile_result = api.compile_project(project_id)\n\nif compile_result['state'] != 'BuildSuccess':\n    print(\"Compilation failed!\")\n    print(\"Logs:\")\n    print(compile_result.get('logs', 'No logs available'))\n    \n    # Common issues:\n    # - Missing imports\n    # - Undefined variables\n    # - Syntax errors\n    # - Emojis in code\n```\n\n---\n\n## Debugging Checklist\n\nWhen backtest fails, check in order:\n\n1. **Compilation** - Does code compile?\n   ```bash\n   compile_result = api.compile_project(project_id)\n   print(compile_result['state'])  # Should be 'BuildSuccess'\n   ```\n\n2. **Emojis** - Remove ALL emojis from code\n   ```bash\n   grep -n '[^\u0000-]' strategy.py  # Find non-ASCII chars\n   ```\n\n3. **Imports** - Only use QC-approved imports\n   ```python\n   from AlgorithmImports import *  # ‚úÖ\n   import requests  # ‚ùå\n   ```\n\n4. **Indicators** - Check IsReady and IsWarmingUp\n   ```python\n   if self.IsWarmingUp or not self.rsi.IsReady:\n       return\n   ```\n\n5. **Securities** - Add in Initialize(), use in OnData()\n   ```python\n   # Initialize()\n   self.spy = self.AddEquity(\"SPY\", Resolution.Daily)\n   \n   # OnData()\n   if self.spy.Symbol in data:\n       price = data[self.spy.Symbol].Close\n   ```\n\n6. **Logs** - Check runtime logs for errors\n   ```python\n   result = api.read_backtest(project_id, backtest_id)\n   logs = result['backtest'].get('logs', [])\n   error_logs = [log for log in logs if 'ERROR' in log or 'Exception' in log]\n   ```",
      "tags": [
        "errors",
        "troubleshooting",
        "debugging"
      ],
      "priority": 1,
      "related_sections": [
        "qc_coding_standards",
        "best_practices"
      ]
    },
    {
      "id": "best_practices",
      "title": "Best Practices for Autonomous Execution",
      "content": "**Autonomous Backtest Execution Patterns**\n\nThese patterns enable Claude Code to work autonomously without user intervention.\n\n---\n\n## 1. Always Check Success Before Proceeding\n\n**Pattern**: Check every API response for success\n\n```python\nfrom qc_api import QuantConnectAPI\n\napi = QuantConnectAPI()\n\n# ‚ùå WRONG - Assume success\nproject = api.create_project(\"Strategy\")\nproject_id = project['projects'][0]['projectId']  # May crash if failed!\n\n# ‚úÖ CORRECT - Check success first\nproject = api.create_project(\"Strategy\")\nif not project.get('success'):\n    print(f\"ERROR: Failed to create project: {project.get('error')}\")\n    exit(1)\n\nproject_id = project['projects'][0]['projectId']\nprint(f\"‚úì Project created: {project_id}\")\n```\n\n**Apply to all operations**:\n- create_project()\n- upload_file()\n- compile_project()\n- create_backtest()\n- wait_for_backtest()\n\n---\n\n## 2. Validate Code Before Upload\n\n**Pattern**: Check for common errors before uploading\n\n```python\ndef validate_strategy_code(code: str) -> tuple[bool, str]:\n    \"\"\"Validate strategy code for common errors.\n    \n    Returns:\n        (is_valid, error_message)\n    \"\"\"\n    # Check 1: No emojis\n    if any(ord(char) > 127 for char in code):\n        return False, \"Code contains non-ASCII characters (emojis?)\"\n    \n    # Check 2: Has Initialize method\n    if 'def Initialize(self)' not in code and 'def initialize(self)' not in code:\n        return False, \"Missing Initialize() method\"\n    \n    # Check 3: Has SetStartDate and SetEndDate\n    if 'SetStartDate' not in code:\n        return False, \"Missing SetStartDate() call\"\n    if 'SetEndDate' not in code:\n        return False, \"Missing SetEndDate() call\"\n    \n    # Check 4: No forbidden imports\n    forbidden = ['requests', 'yfinance', 'ta', 'plotly', 'openai']\n    for lib in forbidden:\n        if f'import {lib}' in code:\n            return False, f\"Forbidden import: {lib}\"\n    \n    # Check 5: Uses snake_case (not PascalCase)\n    if 'class MyStrategy' in code or 'class Strategy' in code:\n        return False, \"Use snake_case for class names, not PascalCase\"\n    \n    return True, \"\"\n\n# Use before upload\nwith open('strategy.py') as f:\n    code = f.read()\n\nis_valid, error = validate_strategy_code(code)\nif not is_valid:\n    print(f\"‚ùå Validation failed: {error}\")\n    print(\"Fix the code before uploading\")\n    exit(1)\n\nprint(\"‚úì Code validation passed\")\napi.upload_file(project_id, \"main.py\", code)\n```\n\n---\n\n## 3. Handle Compilation Errors Gracefully\n\n**Pattern**: Check compilation, retry with fixes if needed\n\n```python\ndef compile_with_retry(api, project_id, max_retries=2):\n    \"\"\"Compile project with automatic retry on common errors.\"\"\"\n    \n    for attempt in range(max_retries):\n        compile_result = api.compile_project(project_id)\n        \n        if compile_result.get('state') == 'BuildSuccess':\n            print(f\"‚úì Compilation successful\")\n            return compile_result['compileId']\n        \n        # Compilation failed\n        logs = compile_result.get('logs', '')\n        print(f\"‚ùå Compilation failed (attempt {attempt + 1}/{max_retries})\")\n        print(f\"Logs:\\n{logs}\")\n        \n        # Check for fixable errors\n        if 'Invalid character in identifier' in logs:\n            print(\"üí° Likely emoji in code - remove emojis and retry\")\n            # Could automatically strip emojis here\n            return None\n        \n        if 'NameError' in logs or 'ImportError' in logs:\n            print(\"üí° Missing import or undefined variable\")\n            return None\n    \n    print(f\"‚ùå Compilation failed after {max_retries} attempts\")\n    return None\n\n# Use\ncompile_id = compile_with_retry(api, project_id)\nif not compile_id:\n    print(\"Cannot proceed without successful compilation\")\n    exit(1)\n```\n\n---\n\n## 4. Use Timeouts and Progress Updates\n\n**Pattern**: Set reasonable timeouts, show progress\n\n```python\nimport time\n\ndef wait_with_progress(api, project_id, backtest_id, timeout=1800):\n    \"\"\"Wait for backtest with progress updates.\"\"\"\n    \n    start_time = time.time()\n    poll_interval = 15\n    \n    while True:\n        elapsed = time.time() - start_time\n        \n        if elapsed > timeout:\n            print(f\"‚ùå Timeout after {timeout}s\")\n            return None\n        \n        # Check status\n        result = api.read_backtest(project_id, backtest_id)\n        status = result.get('backtest', {}).get('status')\n        \n        print(f\"‚è±  {elapsed:.0f}s elapsed - Status: {status}\")\n        \n        if status == 'Completed':\n            print(f\"‚úì Backtest completed in {elapsed:.0f}s\")\n            return result\n        \n        if status in ['Error', 'Failed']:\n            error = result.get('backtest', {}).get('error', 'Unknown error')\n            print(f\"‚ùå Backtest failed: {error}\")\n            return None\n        \n        time.sleep(poll_interval)\n\n# Use\nresult = wait_with_progress(api, project_id, backtest_id, timeout=1800)\nif not result:\n    print(\"Backtest failed or timed out\")\n    exit(1)\n```\n\n---\n\n## 5. Save State at Each Step\n\n**Pattern**: Save progress to file for recovery\n\n```python\nimport json\nfrom datetime import datetime\n\nclass BacktestState:\n    \"\"\"Track backtest state for autonomous recovery.\"\"\"\n    \n    def __init__(self, state_file='backtest_state.json'):\n        self.state_file = state_file\n        self.state = self.load()\n    \n    def load(self):\n        \"\"\"Load state from file.\"\"\"\n        try:\n            with open(self.state_file) as f:\n                return json.load(f)\n        except FileNotFoundError:\n            return {\n                'step': 'init',\n                'project_id': None,\n                'backtest_id': None,\n                'started': datetime.now().isoformat()\n            }\n    \n    def save(self):\n        \"\"\"Save state to file.\"\"\"\n        self.state['updated'] = datetime.now().isoformat()\n        with open(self.state_file, 'w') as f:\n            json.dump(self.state, f, indent=2)\n    \n    def set_step(self, step, **kwargs):\n        \"\"\"Update step and save.\"\"\"\n        self.state['step'] = step\n        self.state.update(kwargs)\n        self.save()\n        print(f\"‚úì State saved: {step}\")\n\n# Use throughout workflow\nstate = BacktestState()\n\n# Step 1: Create project\nif state.state['step'] == 'init':\n    project = api.create_project(\"H5_StatArb\")\n    project_id = project['projects'][0]['projectId']\n    state.set_step('project_created', project_id=project_id)\n\n# Step 2: Upload code\nif state.state['step'] == 'project_created':\n    project_id = state.state['project_id']\n    with open('strategy.py') as f:\n        api.upload_file(project_id, \"main.py\", f.read())\n    state.set_step('code_uploaded')\n\n# Step 3: Compile\nif state.state['step'] == 'code_uploaded':\n    compile_result = api.compile_project(project_id)\n    compile_id = compile_result['compileId']\n    state.set_step('compiled', compile_id=compile_id)\n\n# etc... can resume from any step if interrupted\n```\n\n---\n\n## 6. Implement Automatic Retry Logic\n\n**Pattern**: Retry transient failures automatically\n\n```python\nimport time\nfrom functools import wraps\n\ndef retry_on_failure(max_retries=3, backoff=2):\n    \"\"\"Decorator for automatic retry with exponential backoff.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_retries):\n                try:\n                    result = func(*args, **kwargs)\n                    \n                    # Check if API call succeeded\n                    if isinstance(result, dict) and result.get('success'):\n                        return result\n                    \n                    # Failed but no exception\n                    if attempt < max_retries - 1:\n                        wait = backoff ** attempt\n                        print(f\"‚ö†Ô∏è  Attempt {attempt + 1} failed, retrying in {wait}s...\")\n                        time.sleep(wait)\n                        continue\n                    \n                    return result\n                    \n                except Exception as e:\n                    if attempt < max_retries - 1:\n                        wait = backoff ** attempt\n                        print(f\"‚ùå Exception: {e}, retrying in {wait}s...\")\n                        time.sleep(wait)\n                        continue\n                    raise\n            \n            return result\n        return wrapper\n    return decorator\n\n# Apply to API calls\n@retry_on_failure(max_retries=3, backoff=2)\ndef create_backtest_with_retry(api, project_id, compile_id):\n    return api.create_backtest(project_id, compile_id)\n\n# Use\nresult = create_backtest_with_retry(api, project_id, compile_id)\n```\n\n---\n\n## 7. Log Everything for Debugging\n\n**Pattern**: Comprehensive logging\n\n```python\nimport logging\nfrom datetime import datetime\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(f'backtest_{datetime.now():%Y%m%d_%H%M%S}.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\n# Log all operations\nlogger.info(\"Starting backtest workflow\")\nlogger.info(f\"Project ID: {project_id}\")\n\ntry:\n    result = api.create_backtest(project_id, compile_id)\n    logger.info(f\"Backtest created: {result['backtests'][0]['backtestId']}\")\nexcept Exception as e:\n    logger.error(f\"Failed to create backtest: {e}\", exc_info=True)\n    raise\n```\n\n---\n\n## 8. Complete Autonomous Workflow Template\n\n```python\nfrom qc_api import QuantConnectAPI, parse_backtest_results\nimport json\nimport logging\nfrom datetime import datetime\n\n# Setup\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef run_autonomous_backtest(strategy_file: str, project_name: str):\n    \"\"\"Fully autonomous backtest execution with error handling.\"\"\"\n    \n    api = QuantConnectAPI()\n    \n    try:\n        # Step 1: Validate code\n        logger.info(\"Validating strategy code...\")\n        with open(strategy_file) as f:\n            code = f.read()\n        \n        # Check for emojis\n        if any(ord(c) > 127 for c in code):\n            logger.error(\"Code contains non-ASCII characters (emojis)\")\n            return None\n        \n        # Step 2: Create project\n        logger.info(f\"Creating project: {project_name}\")\n        project = api.create_project(project_name)\n        if not project.get('success'):\n            logger.error(f\"Failed to create project: {project.get('error')}\")\n            return None\n        \n        project_id = project['projects'][0]['projectId']\n        logger.info(f\"‚úì Project created: {project_id}\")\n        \n        # Step 3: Upload code\n        logger.info(\"Uploading strategy code...\")\n        upload = api.upload_file(project_id, \"main.py\", code)\n        if not upload.get('success'):\n            logger.error(\"Failed to upload code\")\n            return None\n        logger.info(\"‚úì Code uploaded\")\n        \n        # Step 4: Compile\n        logger.info(\"Compiling project...\")\n        compile_result = api.compile_project(project_id)\n        if compile_result.get('state') != 'BuildSuccess':\n            logger.error(f\"Compilation failed:\\n{compile_result.get('logs')}\")\n            return None\n        logger.info(\"‚úì Compilation successful\")\n        \n        # Step 5: Create backtest\n        logger.info(\"Creating backtest...\")\n        backtest = api.create_backtest(project_id, compile_result['compileId'])\n        if not backtest.get('success'):\n            logger.error(\"Failed to create backtest\")\n            return None\n        \n        backtest_id = backtest['backtests'][0]['backtestId']\n        logger.info(f\"‚úì Backtest created: {backtest_id}\")\n        \n        # Step 6: Wait for completion\n        logger.info(\"Waiting for backtest to complete...\")\n        result = api.wait_for_backtest(project_id, backtest_id, timeout=1800)\n        if not result.get('success'):\n            logger.error(\"Backtest failed or timed out\")\n            return None\n        logger.info(\"‚úì Backtest completed\")\n        \n        # Step 7: Parse results\n        logger.info(\"Parsing results...\")\n        metrics = parse_backtest_results(result)\n        \n        if metrics.get('error'):\n            logger.error(f\"Backtest error: {metrics['error']}\")\n            return None\n        \n        # Step 8: Save results\n        output_file = f\"backtest_results_{datetime.now():%Y%m%d_%H%M%S}.json\"\n        with open(output_file, 'w') as f:\n            json.dump(metrics, f, indent=2)\n        logger.info(f\"‚úì Results saved: {output_file}\")\n        \n        # Step 9: Print summary\n        logger.info(\"=\" * 60)\n        logger.info(f\"BACKTEST COMPLETE: {metrics['name']}\")\n        logger.info(f\"Sharpe Ratio: {metrics['performance']['sharpe_ratio']:.2f}\")\n        logger.info(f\"Max Drawdown: {metrics['performance']['max_drawdown']:.1%}\")\n        logger.info(f\"Total Return: {metrics['performance']['total_return']:.1%}\")\n        logger.info(\"=\" * 60)\n        \n        return metrics\n        \n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        return None\n\n# Run autonomously\nif __name__ == \"__main__\":\n    results = run_autonomous_backtest(\"strategy.py\", \"H5_StatArb\")\n    if results:\n        print(\"‚úÖ Backtest succeeded\")\n    else:\n        print(\"‚ùå Backtest failed\")\n        exit(1)\n```\n\n**This template provides**:\n- ‚úÖ Validation before upload\n- ‚úÖ Error checking at every step\n- ‚úÖ Comprehensive logging\n- ‚úÖ Automatic result saving\n- ‚úÖ Clean exit codes\n- ‚úÖ No user intervention needed\n- ‚úÖ Full error context for debugging",
      "tags": [
        "best_practices",
        "autonomous",
        "patterns",
        "reliability"
      ],
      "priority": 1,
      "related_sections": [
        "common_errors",
        "reading_results"
      ]
    }
  ],
  "metadata": {
    "created": "2025-11-13",
    "updated": "2025-11-13",
    "version": "1.3.0",
    "authors": [
      "Claude"
    ],
    "skill": "quantconnect-backtest",
    "changelog": "v1.3.0: Added Common Errors and Best Practices sections for autonomous execution. v1.2.0: Added Reading Results. v1.1.0: Added CLI/API sections"
  }
}